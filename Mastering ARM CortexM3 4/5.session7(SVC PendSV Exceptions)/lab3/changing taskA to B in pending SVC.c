/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "core_cm3.h"
#include "STM32F103X6.h"
#include "GPIO.h"
#include "LCD.h"
#include "EXTI.h"

#define OS_Stack_Size			512
#define TaskA_Stack_Size		100
#define TaskB_Stack_Size		100

extern unsigned int _estack;

//boundary of Main Stack Pointer (MSP)
unsigned int _S_MSP = (unsigned int)&_estack;
unsigned int _E_MSP;

//boundary of Process Stack Pointer of TaskA (PSP_TA)
unsigned int _S_PSP_TaskA;
unsigned int _E_PSP_TaskA;


//boundary of Process Stack Pointer of TaskB (PSP_TB)
unsigned int _S_PSP_TaskB;
unsigned int _E_PSP_TaskB;

#define TASKA		1
#define TASKB		2

uint8_t IRQ_Flag = 0;
uint8_t Task_Flag = 0;

void Clock_Init()
{
	//open clock of AFIO
	RCC_AFIO_CLK_EN();

	//open clock of GPIOA
	RCC_GPIOA_CLK_EN();

	//open clock of GPIOB
	RCC_GPIOB_CLK_EN();
}



#define Os_Set_PSP_VAL(address)  						__asm volatile("MOV r0,%[IN] \n\t MSR PSP,r0" : :[IN]"r" (address))

#define OS_SwitchTo_PSP 								__asm volatile("MRS r0,CONTROL \n\t MOV r1,#0x02 \n\t ORR r0,r0,r1 \n\t MSR CONTROL,r0")

#define OS_SwitchTo_MSP 								__asm volatile("MRS r0,CONTROL \n\t MOV r1,#0x05 \n\t AND r0,r0,r1 \n\t MSR CONTROL,r0")

#define OS_Switch_Privileged_to_Unprivileged			__asm volatile("MRS R0, CONTROL \n\t MOV R1, #0x01 \n\t \
																		ORR R0, R0, R1 \n\t MSR CONTROL, R0")

#define OS_Switch_Unprivileged_to_Privileged			__asm volatile("MRS R0, CONTROL \n\t MOV R1, #0x06 \n\t \
																		AND R0, R0, R1 \n\t MSR CONTROL, R0")

#define OS_Generate_Exception_Inerrupt					__asm("SVC #0x3")



void TaskA(void)
{
	GPIO_WRITE_Pin(GPIOB, GPIO_PIN_0, GPIO_HIGH);
	GPIO_WRITE_Pin(GPIOB, GPIO_PIN_1, GPIO_LOW);
}

void TaskB(void)
{
	GPIO_WRITE_Pin(GPIOB, GPIO_PIN_0, GPIO_LOW);
	GPIO_WRITE_Pin(GPIOB, GPIO_PIN_1, GPIO_HIGH);
}

void Os_SVC_Services(unsigned int *Stack_Pointer)
{
	unsigned char SVC_ID;

	SVC_ID = *((unsigned char *)(((unsigned char *)Stack_Pointer[6])-2));

	switch(SVC_ID)
	{
		case 1: //TaskA
			Os_Set_PSP_VAL(_S_PSP_TaskA);
			OS_SwitchTo_PSP;
			OS_Switch_Privileged_to_Unprivileged;
		break;

		case 2: //TaskB
			Os_Set_PSP_VAL(_S_PSP_TaskB);
			OS_SwitchTo_PSP;
			OS_Switch_Privileged_to_Unprivileged;
		break;
	}
}

void Os_Set_Task(int SVC_ID)
{
	switch(SVC_ID)
	{
		case 1:	//TaskA
			__asm("SVC #0x01");
		break;

		case 2:	//TaskB
			__asm("SVC #0x02");
		break;
	}
}
void PendSV_Handler(void)
{
	if(Task_Flag == TASKA)
	{
		Os_Set_PSP_VAL(_S_PSP_TaskA);
		OS_SwitchTo_PSP;
	}
	else if(Task_Flag == TASKB)
	{
		Os_Set_PSP_VAL(_S_PSP_TaskB);
		OS_SwitchTo_PSP;
	}
}

__attribute((naked)) void SVC_Handler()
{
	__asm("tst lr,#4 \n\t"
		  "ITE EQ \n\t"
		  "mrseq r0,MSP \n\t"
		  "mrsne r0,PSP \n\t"
		  "B Os_SVC_Services");
}




void Main_Os(void)
{
	//Os stack
	_E_MSP = _S_MSP - OS_Stack_Size;

	//TA stack
	_S_PSP_TaskA = _E_MSP - 8;
	_E_PSP_TaskA = _S_PSP_TaskA - TaskA_Stack_Size;

	//TB stack
	_S_PSP_TaskB = _E_PSP_TaskA - 8;
	_E_PSP_TaskB = _S_PSP_TaskB - TaskB_Stack_Size;

	Os_Set_Task(Task_Flag);

	while(1)
	{
		if(Task_Flag == TASKA)
		{
			TaskA();
		}
		else if(Task_Flag == TASKB)
		{
			TaskB();
		}

	}
}

void EXTI9_callback(void)
{

	if(IRQ_Flag = 0)
	{
		Task_Flag = TASKA;
		IRQ_Flag = 1;
	}
	else if(IRQ_Flag = 1)
	{
		Task_Flag = TASKB;
		IRQ_Flag = 0;
	}
	else
	{

	}

	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;//1<<28

}

int main(void)
{
	Clock_Init();

	GPIO_Config_t pin_config;

	pin_config.GPIO_PinMode = GPIO_MODE_OUTPUT_PP;
	pin_config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
	pin_config.GPIO_PinNumber = GPIO_PIN_0;
	GPIO_Init(GPIOB, &pin_config);

	pin_config.GPIO_PinMode = GPIO_MODE_OUTPUT_PP;
	pin_config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
	pin_config.GPIO_PinNumber = GPIO_PIN_1;
	GPIO_Init(GPIOB, &pin_config);

	EXTI_PINCONFIG_t EXTI_CFG;
	EXTI_CFG.EXTI_PIN = EXTI9PB9;
	EXTI_CFG.Trigger = EXTI_Trigger_RISING;
	EXTI_CFG.IRQ_EN = 1;
	EXTI_CFG.IRQ_CallBack = EXTI9_callback;
	EXTI_Init(&EXTI_CFG);

	IRQ_Flag = 1;
	Task_Flag = TASKA;

	Main_Os();



	/* Loop forever */
	while(1)
	{
		if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else
		{

		}

	}
}

