/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "stdio.h"
#include "string.h"
#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include "semphr.h"
#include "task.h"
#include "STM32F103X6.h"
#include "RCC_DRIVER_STM32F103C6.h"
#include "GPIO_DRIVER_STM32F103C6.h"
#include "USART_DRIVER_STM32F103C6.h"


char UART_Message[60] ;
#define Taken		0
#define Given		1


TaskHandle_t Task1 = NULL ;
TaskHandle_t Task2 = NULL ;
TaskHandle_t Task3 = NULL ;

SemaphoreHandle_t Semaphore1 = NULL ;
SemaphoreHandle_t Semaphore2 = NULL ;

void FunUARTConfig(void) ;
void FunLED(void) ;
void FunPrintSemaphoreState(char tasknum , char semaphNum , char semaphrstate) ;

void Task1Handler(void *parms) ;
void Task2Handler(void *parms) ;
void Task3Handler(void *parms) ;


void Clock_init(void)
{
	RCC_GPIOA_CLK_EN() ;
	RCC_GPIOB_CLK_EN() ;
	RCC_AFIO_CLK_EN() ;
}

void FunUARTConfig(void)
{

	UART_Config uart1CFG ;
	uart1CFG.BaudRate = UART_BaudRate_115200;
	uart1CFG.HW_Flow_Conterl = UART_HW_Flow_Conterl_NONE;
	uart1CFG.IRQ_Enable = UART_IRQ_Enable_RXNEIE;
	uart1CFG.Parity = UART_Parity_NONE;
	uart1CFG.Payload_length = UART_Payload_length_8B;
	uart1CFG.Stop_Bits = UART_Stop_Bits_1;
	uart1CFG.UART_Mode = UART_Mode_TX_RX;
	MCAL_UART_Init(USART2, &uart1CFG);
	MCAL_UART_GPIO_Set_Pins(USART2);

}

void FunLED(void)
{

	GPIO_PinConfig_t PIN13AGF ;
	PIN13AGF.GPIO_PinNumber = GPIO_PIN_13 ;
	PIN13AGF.GPIO_MODE = GPIO_MODE_Output_push_pull  ;
	PIN13AGF.GPIO_Output_Speed = GPIO_Output_Speed_10M ;
	MCAL_GPIO_Init(GPIOA, &PIN13AGF) ;
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_13, 0) ;

	GPIO_PinConfig_t PIN12AGF ;
	PIN12AGF.GPIO_PinNumber = GPIO_PIN_12 ;
	PIN12AGF.GPIO_MODE = GPIO_MODE_Output_push_pull  ;
	PIN12AGF.GPIO_Output_Speed = GPIO_Output_Speed_10M ;
	MCAL_GPIO_Init(GPIOA, &PIN12AGF) ;
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, 0) ;

	GPIO_PinConfig_t PIN11AGF ;
	PIN11AGF.GPIO_PinNumber = GPIO_PIN_11 ;
	PIN11AGF.GPIO_MODE = GPIO_MODE_Output_push_pull  ;
	PIN11AGF.GPIO_Output_Speed = GPIO_Output_Speed_10M ;
	MCAL_GPIO_Init(GPIOA, &PIN11AGF) ;
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0) ;

	GPIO_PinConfig_t PIN10BGF_Tick ;
	PIN10BGF_Tick.GPIO_PinNumber = GPIO_PIN_10 ;
	PIN10BGF_Tick.GPIO_MODE = GPIO_MODE_Output_push_pull  ;
	PIN10BGF_Tick.GPIO_Output_Speed = GPIO_Output_Speed_10M ;
	MCAL_GPIO_Init(GPIOB, &PIN10BGF_Tick) ;
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, 0) ;

}

int main(void)
{
	Clock_init() ;
	FunUARTConfig() ;
	FunLED();
	xTaskCreate(Task1Handler, " TASK1 ", 128, NULL, 1, Task1) ;
	xTaskCreate(Task2Handler, " TASK2 ", 128, NULL, 2, Task2) ;
	xTaskCreate(Task3Handler, " TASK3 ", 128, NULL, 3, Task3) ;

	Semaphore1 = xSemaphoreCreateBinary() ;
	Semaphore2 = xSemaphoreCreateBinary() ;

	xSemaphoreGive(Semaphore1) ;
	xSemaphoreGive(Semaphore2) ;

	vTaskStartScheduler() ;

	/* Loop forever */
	while(1);

}

void FunPrintSemaphoreState(char tasknum , char semaphNum , char semaphrstate)
{
	int count = 0 ;
	if(semaphrstate == Taken)
	{
		strcpy(UART_Message , "\nTask  : The Semaphore 	 was Taken by Me \n" ) ;

		UART_Message[6] = tasknum ;
		UART_Message[23] = semaphNum ;

		for(count =0 ; count<strlen(UART_Message) ;count++)
		{
			MCAL_UART_Send_Data(USART2, (UART_Message+count), Enable) ;
		}
	}
	else if(semaphrstate == Given)
	{
		strcpy(UART_Message , "\nTask  : The Semaphore 	 was Given by Me \n" ) ;

		UART_Message[6] = tasknum ;
		UART_Message[23] = semaphNum ;

		for(count =0 ; count<strlen(UART_Message) ;count++)
		{
			MCAL_UART_Send_Data(USART2, (UART_Message+count), Enable) ;
		}
	}
}

void Task1Handler(void *parms)
{
	int i = 0 , flag = 0 ;
	int lastWakeTime = xTaskGetTickCount() ;

	while(1)
	{

		if(xSemaphoreTake(Semaphore1 , portMAX_DELAY) == 1)
		{
			FunPrintSemaphoreState('1' , '1' , Taken) ;
		}

		if(xSemaphoreTake(Semaphore2 , portMAX_DELAY) == 1)
		{
			FunPrintSemaphoreState('1' , '2' , Taken) ;
		}
		/*flag = 0 ;

		for(i = 0 ; i<300000 ; i++)
		{
			if(i>200000 && flag==0)
			{
				flag = 1 ;
				if(xSemaphoreTake(Semaphore2 , portMAX_DELAY) == 1)
				{
					FunPrintSemaphoreState('1' , '2' , Taken) ;
				}
			}
		}*/

		MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, 0) ;
		vTaskDelay(10) ;
		MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, 1) ;
		vTaskDelay(10) ;

		if(xSemaphoreGive(Semaphore1) == 1)
		{
			FunPrintSemaphoreState('1' , '1' , Given) ;
		}

		if(xSemaphoreGive(Semaphore2) == 1)
		{
			FunPrintSemaphoreState('1' , '2' , Given) ;
		}

		vTaskDelayUntil(&lastWakeTime , 120) ;

	}
}

void Task2Handler(void *parms)
{
	int LastWakeTime = xTaskGetTickCount() ;
	while(1)
	{
		MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_13, 0) ;
		vTaskDelay(10) ;

		MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_13, 1) ;
		vTaskDelay(10) ;

		vTaskDelayUntil(&LastWakeTime,120) ;
	}

}

void Task3Handler(void *parms)
{
	int LastWakeTime = xTaskGetTickCount() ;

	while(1)
	{
		if(xSemaphoreTake(Semaphore2 ,portMAX_DELAY) == 1)
		{
			FunPrintSemaphoreState('3' , '2' , Taken) ;
		}

		if(xSemaphoreTake(Semaphore1 ,portMAX_DELAY) == 1)
		{
			FunPrintSemaphoreState('3' , '1' , Taken) ;
		}

		MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0) ;
		vTaskDelay(10) ;
		MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1) ;
		vTaskDelay(10) ;

		if(xSemaphoreGive(Semaphore2) == 1)
		{
			FunPrintSemaphoreState('3' , '2' , Given) ;
		}

		if(xSemaphoreGive(Semaphore1) == 1)
		{
			FunPrintSemaphoreState('3' , '1' , Given) ;
		}
		vTaskDelayUntil(&LastWakeTime,120) ;
	}
}

void vApplicationTickHook( void )
{
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, 0) ;
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, 1) ;
}
