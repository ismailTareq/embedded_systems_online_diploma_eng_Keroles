
Drivers.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000011c8  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000020  080012f8  080012f8  000112f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08001318  08001318  00011320  2**0
                  CONTENTS
  4 .ARM          00000000  08001318  08001318  00011320  2**0
                  CONTENTS
  5 .preinit_array 00000000  08001318  08001320  00011320  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08001318  08001318  00011318  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800131c  0800131c  0001131c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000000  20000000  20000000  00011320  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000000b4  20000000  08001320  00020000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200000b4  08001320  000200b4  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00011320  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00011349  2**0
                  CONTENTS, READONLY
 13 .debug_info   000027ed  00000000  00000000  0001138c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00000c34  00000000  00000000  00013b79  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    000012ce  00000000  00000000  000147ad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000002e0  00000000  00000000  00015a80  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00000258  00000000  00000000  00015d60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0000248b  00000000  00000000  00015fb8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00001925  00000000  00000000  00018443  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0000847d  00000000  00000000  00019d68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_frame  00000984  00000000  00000000  000221e8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000000 	.word	0x20000000
 800014c:	00000000 	.word	0x00000000
 8000150:	080012e0 	.word	0x080012e0

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	20000004 	.word	0x20000004
 800016c:	080012e0 	.word	0x080012e0

08000170 <EEPROM_Init>:
 */

#include "EEPROM.h"

void EEPROM_Init(void)
{
 8000170:	b580      	push	{r7, lr}
 8000172:	b08a      	sub	sp, #40	; 0x28
 8000174:	af00      	add	r7, sp, #0
	I2C_Config_t I2C_Config;

		/* I2C Controller as Master */
		I2C_Config.General_Call = I2C_GENERAL_CALL_ENABLE;
 8000176:	2340      	movs	r3, #64	; 0x40
 8000178:	60bb      	str	r3, [r7, #8]
		I2C_Config.I2C_Mode = I2C_MODE_I2C;
 800017a:	2300      	movs	r3, #0
 800017c:	613b      	str	r3, [r7, #16]
		I2C_Config.Stretch_Mode = I2C_STRETCH_MODE_ENABLE;
 800017e:	2300      	movs	r3, #0
 8000180:	607b      	str	r3, [r7, #4]
		I2C_Config.Master_Mode = I2C_MASTER_MODE_SM;
 8000182:	2300      	movs	r3, #0
 8000184:	60fb      	str	r3, [r7, #12]
		I2C_Config.Clock_Speed = I2C_CLOCK_SPEED_100KHZ;
 8000186:	4b09      	ldr	r3, [pc, #36]	; (80001ac <EEPROM_Init+0x3c>)
 8000188:	603b      	str	r3, [r7, #0]
		I2C_Config.ACK_Control = I2C_ACK_CONTROL_ENABLE;
 800018a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800018e:	617b      	str	r3, [r7, #20]
		I2C_Config.Slave_CallBack = NULL;
 8000190:	2300      	movs	r3, #0
 8000192:	627b      	str	r3, [r7, #36]	; 0x24

		I2C_Init(I2C1, &I2C_Config);
 8000194:	463b      	mov	r3, r7
 8000196:	4619      	mov	r1, r3
 8000198:	4805      	ldr	r0, [pc, #20]	; (80001b0 <EEPROM_Init+0x40>)
 800019a:	f000 fb9f 	bl	80008dc <I2C_Init>
		I2C_GPIO_SetPins(I2C1);
 800019e:	4804      	ldr	r0, [pc, #16]	; (80001b0 <EEPROM_Init+0x40>)
 80001a0:	f000 fcb2 	bl	8000b08 <I2C_GPIO_SetPins>
}
 80001a4:	bf00      	nop
 80001a6:	3728      	adds	r7, #40	; 0x28
 80001a8:	46bd      	mov	sp, r7
 80001aa:	bd80      	pop	{r7, pc}
 80001ac:	000186a0 	.word	0x000186a0
 80001b0:	40005400 	.word	0x40005400

080001b4 <EEPROM_Write_NBytes>:

uint8_t EEPROM_Write_NBytes(uint32_t Memory_Address, uint8_t *Byte, uint32_t Data_Length)
{
 80001b4:	b580      	push	{r7, lr}
 80001b6:	b0c8      	sub	sp, #288	; 0x120
 80001b8:	af02      	add	r7, sp, #8
 80001ba:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80001be:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80001c2:	6018      	str	r0, [r3, #0]
 80001c4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80001c8:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 80001cc:	6019      	str	r1, [r3, #0]
 80001ce:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80001d2:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80001d6:	601a      	str	r2, [r3, #0]
	int i = 0;
 80001d8:	2300      	movs	r3, #0
 80001da:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114

	uint8_t Buffer[256];

	Buffer[0] = (uint8_t)(Memory_Address >> 8);		/* High Address */
 80001de:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80001e2:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80001e6:	681b      	ldr	r3, [r3, #0]
 80001e8:	0a1b      	lsrs	r3, r3, #8
 80001ea:	b2da      	uxtb	r2, r3
 80001ec:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80001f0:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80001f4:	701a      	strb	r2, [r3, #0]
	Buffer[1] = (uint8_t)(Memory_Address);			/* Low Address  */
 80001f6:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80001fa:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80001fe:	681b      	ldr	r3, [r3, #0]
 8000200:	b2da      	uxtb	r2, r3
 8000202:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8000206:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800020a:	705a      	strb	r2, [r3, #1]

	for(i = 2; i < (Data_Length+2); i++)
 800020c:	2302      	movs	r3, #2
 800020e:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 8000212:	e017      	b.n	8000244 <EEPROM_Write_NBytes+0x90>
	{
		Buffer[i]= Byte[i-2];
 8000214:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8000218:	3b02      	subs	r3, #2
 800021a:	f507 728c 	add.w	r2, r7, #280	; 0x118
 800021e:	f5a2 7288 	sub.w	r2, r2, #272	; 0x110
 8000222:	6812      	ldr	r2, [r2, #0]
 8000224:	4413      	add	r3, r2
 8000226:	7819      	ldrb	r1, [r3, #0]
 8000228:	f507 738c 	add.w	r3, r7, #280	; 0x118
 800022c:	f5a3 7282 	sub.w	r2, r3, #260	; 0x104
 8000230:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8000234:	4413      	add	r3, r2
 8000236:	460a      	mov	r2, r1
 8000238:	701a      	strb	r2, [r3, #0]
	for(i = 2; i < (Data_Length+2); i++)
 800023a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 800023e:	3301      	adds	r3, #1
 8000240:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 8000244:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8000248:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 800024c:	681b      	ldr	r3, [r3, #0]
 800024e:	1c9a      	adds	r2, r3, #2
 8000250:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8000254:	429a      	cmp	r2, r3
 8000256:	d8dd      	bhi.n	8000214 <EEPROM_Write_NBytes+0x60>
	}

	I2C_MASTER_SendData(I2C1, EEPROM_Slave_Address, Buffer, (Data_Length+2), With_STOP, START);
 8000258:	f507 738c 	add.w	r3, r7, #280	; 0x118
 800025c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8000260:	681b      	ldr	r3, [r3, #0]
 8000262:	b2db      	uxtb	r3, r3
 8000264:	3302      	adds	r3, #2
 8000266:	b2db      	uxtb	r3, r3
 8000268:	f107 0214 	add.w	r2, r7, #20
 800026c:	2100      	movs	r1, #0
 800026e:	9101      	str	r1, [sp, #4]
 8000270:	2100      	movs	r1, #0
 8000272:	9100      	str	r1, [sp, #0]
 8000274:	212a      	movs	r1, #42	; 0x2a
 8000276:	4804      	ldr	r0, [pc, #16]	; (8000288 <EEPROM_Write_NBytes+0xd4>)
 8000278:	f000 fc90 	bl	8000b9c <I2C_MASTER_SendData>
}
 800027c:	bf00      	nop
 800027e:	4618      	mov	r0, r3
 8000280:	f507 778c 	add.w	r7, r7, #280	; 0x118
 8000284:	46bd      	mov	sp, r7
 8000286:	bd80      	pop	{r7, pc}
 8000288:	40005400 	.word	0x40005400

0800028c <EEPROM_Read_NBytes>:
uint8_t EEPROM_Read_NBytes(uint32_t Memory_Address, uint8_t *Byte, uint32_t Data_Length)
{
 800028c:	b580      	push	{r7, lr}
 800028e:	b088      	sub	sp, #32
 8000290:	af02      	add	r7, sp, #8
 8000292:	60f8      	str	r0, [r7, #12]
 8000294:	60b9      	str	r1, [r7, #8]
 8000296:	607a      	str	r2, [r7, #4]
	uint8_t Buffer[2];

	Buffer[0] = (uint8_t)(Memory_Address >> 8);		/* High Address */
 8000298:	68fb      	ldr	r3, [r7, #12]
 800029a:	0a1b      	lsrs	r3, r3, #8
 800029c:	b2db      	uxtb	r3, r3
 800029e:	753b      	strb	r3, [r7, #20]
	Buffer[1] = (uint8_t)(Memory_Address);			/* Low Address  */
 80002a0:	68fb      	ldr	r3, [r7, #12]
 80002a2:	b2db      	uxtb	r3, r3
 80002a4:	757b      	strb	r3, [r7, #21]

	I2C_MASTER_SendData(I2C1, EEPROM_Slave_Address, Buffer, 2, Without_STOP, START);
 80002a6:	f107 0214 	add.w	r2, r7, #20
 80002aa:	2300      	movs	r3, #0
 80002ac:	9301      	str	r3, [sp, #4]
 80002ae:	2301      	movs	r3, #1
 80002b0:	9300      	str	r3, [sp, #0]
 80002b2:	2302      	movs	r3, #2
 80002b4:	212a      	movs	r1, #42	; 0x2a
 80002b6:	4809      	ldr	r0, [pc, #36]	; (80002dc <EEPROM_Read_NBytes+0x50>)
 80002b8:	f000 fc70 	bl	8000b9c <I2C_MASTER_SendData>
	I2C_MASTER_ReceiveData(I2C1, EEPROM_Slave_Address, Byte, Data_Length, With_STOP, Repeated_START);
 80002bc:	687b      	ldr	r3, [r7, #4]
 80002be:	b2db      	uxtb	r3, r3
 80002c0:	2201      	movs	r2, #1
 80002c2:	9201      	str	r2, [sp, #4]
 80002c4:	2200      	movs	r2, #0
 80002c6:	9200      	str	r2, [sp, #0]
 80002c8:	68ba      	ldr	r2, [r7, #8]
 80002ca:	212a      	movs	r1, #42	; 0x2a
 80002cc:	4803      	ldr	r0, [pc, #12]	; (80002dc <EEPROM_Read_NBytes+0x50>)
 80002ce:	f000 fcbd 	bl	8000c4c <I2C_MASTER_ReceiveData>
	return 0;
 80002d2:	2300      	movs	r3, #0

}
 80002d4:	4618      	mov	r0, r3
 80002d6:	3718      	adds	r7, #24
 80002d8:	46bd      	mov	sp, r7
 80002da:	bd80      	pop	{r7, pc}
 80002dc:	40005400 	.word	0x40005400

080002e0 <main>:
/* ========== Prototypes ========= */
static void Clock_Init(void);


int main(void)
{
 80002e0:	b580      	push	{r7, lr}
 80002e2:	b084      	sub	sp, #16
 80002e4:	af00      	add	r7, sp, #0
	/* Initialization */
	Clock_Init();
 80002e6:	f000 f83d 	bl	8000364 <Clock_Init>

	EEPROM_Init();
 80002ea:	f7ff ff41 	bl	8000170 <EEPROM_Init>

	uint8_t CH1_To_Write[7] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07};
 80002ee:	4a1c      	ldr	r2, [pc, #112]	; (8000360 <main+0x80>)
 80002f0:	f107 0308 	add.w	r3, r7, #8
 80002f4:	e892 0003 	ldmia.w	r2, {r0, r1}
 80002f8:	6018      	str	r0, [r3, #0]
 80002fa:	3304      	adds	r3, #4
 80002fc:	8019      	strh	r1, [r3, #0]
 80002fe:	3302      	adds	r3, #2
 8000300:	0c0a      	lsrs	r2, r1, #16
 8000302:	701a      	strb	r2, [r3, #0]
	uint8_t CH2_To_Read[7] = {0};
 8000304:	2300      	movs	r3, #0
 8000306:	603b      	str	r3, [r7, #0]
 8000308:	1d3b      	adds	r3, r7, #4
 800030a:	2100      	movs	r1, #0
 800030c:	460a      	mov	r2, r1
 800030e:	801a      	strh	r2, [r3, #0]
 8000310:	460a      	mov	r2, r1
 8000312:	709a      	strb	r2, [r3, #2]

	EEPROM_Write_NBytes(0xAF, CH1_To_Write, 7);
 8000314:	f107 0308 	add.w	r3, r7, #8
 8000318:	2207      	movs	r2, #7
 800031a:	4619      	mov	r1, r3
 800031c:	20af      	movs	r0, #175	; 0xaf
 800031e:	f7ff ff49 	bl	80001b4 <EEPROM_Write_NBytes>
	EEPROM_Read_NBytes(0xAF, CH2_To_Read, 7);
 8000322:	463b      	mov	r3, r7
 8000324:	2207      	movs	r2, #7
 8000326:	4619      	mov	r1, r3
 8000328:	20af      	movs	r0, #175	; 0xaf
 800032a:	f7ff ffaf 	bl	800028c <EEPROM_Read_NBytes>



	CH1_To_Write[0] = 0xA;
 800032e:	230a      	movs	r3, #10
 8000330:	723b      	strb	r3, [r7, #8]
	CH1_To_Write[1] = 0xB;
 8000332:	230b      	movs	r3, #11
 8000334:	727b      	strb	r3, [r7, #9]
	CH1_To_Write[2] = 0xC;
 8000336:	230c      	movs	r3, #12
 8000338:	72bb      	strb	r3, [r7, #10]
	CH1_To_Write[3] = 0xD;
 800033a:	230d      	movs	r3, #13
 800033c:	72fb      	strb	r3, [r7, #11]

	EEPROM_Write_NBytes(0xFFF, CH1_To_Write, 4);
 800033e:	f107 0308 	add.w	r3, r7, #8
 8000342:	2204      	movs	r2, #4
 8000344:	4619      	mov	r1, r3
 8000346:	f640 70ff 	movw	r0, #4095	; 0xfff
 800034a:	f7ff ff33 	bl	80001b4 <EEPROM_Write_NBytes>
	EEPROM_Read_NBytes(0xFFF, CH2_To_Read, 4);
 800034e:	463b      	mov	r3, r7
 8000350:	2204      	movs	r2, #4
 8000352:	4619      	mov	r1, r3
 8000354:	f640 70ff 	movw	r0, #4095	; 0xfff
 8000358:	f7ff ff98 	bl	800028c <EEPROM_Read_NBytes>

	/* Loop For Ever */
	while(1){}
 800035c:	e7fe      	b.n	800035c <main+0x7c>
 800035e:	bf00      	nop
 8000360:	080012f8 	.word	0x080012f8

08000364 <Clock_Init>:
	return 0;
}
/* ======== clock Initialize definition ======= */
static void Clock_Init(void)
{
 8000364:	b480      	push	{r7}
 8000366:	af00      	add	r7, sp, #0
	/* Enable clock GPIOA */
	RCC_GPIOA_CLK_EN();
 8000368:	4b0a      	ldr	r3, [pc, #40]	; (8000394 <Clock_Init+0x30>)
 800036a:	699b      	ldr	r3, [r3, #24]
 800036c:	4a09      	ldr	r2, [pc, #36]	; (8000394 <Clock_Init+0x30>)
 800036e:	f043 0304 	orr.w	r3, r3, #4
 8000372:	6193      	str	r3, [r2, #24]

	/* Enable clock GPIOB */
	RCC_GPIOB_CLK_EN();
 8000374:	4b07      	ldr	r3, [pc, #28]	; (8000394 <Clock_Init+0x30>)
 8000376:	699b      	ldr	r3, [r3, #24]
 8000378:	4a06      	ldr	r2, [pc, #24]	; (8000394 <Clock_Init+0x30>)
 800037a:	f043 0308 	orr.w	r3, r3, #8
 800037e:	6193      	str	r3, [r2, #24]

	/* Enable Clock For AFIO */
	RCC_AFIO_CLK_EN();
 8000380:	4b04      	ldr	r3, [pc, #16]	; (8000394 <Clock_Init+0x30>)
 8000382:	699b      	ldr	r3, [r3, #24]
 8000384:	4a03      	ldr	r2, [pc, #12]	; (8000394 <Clock_Init+0x30>)
 8000386:	f043 0301 	orr.w	r3, r3, #1
 800038a:	6193      	str	r3, [r2, #24]
}
 800038c:	bf00      	nop
 800038e:	46bd      	mov	sp, r7
 8000390:	bc80      	pop	{r7}
 8000392:	4770      	bx	lr
 8000394:	40021000 	.word	0x40021000

08000398 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000398:	480d      	ldr	r0, [pc, #52]	; (80003d0 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800039a:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 800039c:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80003a0:	480c      	ldr	r0, [pc, #48]	; (80003d4 <LoopForever+0x6>)
  ldr r1, =_edata
 80003a2:	490d      	ldr	r1, [pc, #52]	; (80003d8 <LoopForever+0xa>)
  ldr r2, =_sidata
 80003a4:	4a0d      	ldr	r2, [pc, #52]	; (80003dc <LoopForever+0xe>)
  movs r3, #0
 80003a6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80003a8:	e002      	b.n	80003b0 <LoopCopyDataInit>

080003aa <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80003aa:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80003ac:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80003ae:	3304      	adds	r3, #4

080003b0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80003b0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80003b2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80003b4:	d3f9      	bcc.n	80003aa <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80003b6:	4a0a      	ldr	r2, [pc, #40]	; (80003e0 <LoopForever+0x12>)
  ldr r4, =_ebss
 80003b8:	4c0a      	ldr	r4, [pc, #40]	; (80003e4 <LoopForever+0x16>)
  movs r3, #0
 80003ba:	2300      	movs	r3, #0
  b LoopFillZerobss
 80003bc:	e001      	b.n	80003c2 <LoopFillZerobss>

080003be <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80003be:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80003c0:	3204      	adds	r2, #4

080003c2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80003c2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80003c4:	d3fb      	bcc.n	80003be <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80003c6:	f000 ff67 	bl	8001298 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80003ca:	f7ff ff89 	bl	80002e0 <main>

080003ce <LoopForever>:

LoopForever:
  b LoopForever
 80003ce:	e7fe      	b.n	80003ce <LoopForever>
  ldr   r0, =_estack
 80003d0:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 80003d4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80003d8:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 80003dc:	08001320 	.word	0x08001320
  ldr r2, =_sbss
 80003e0:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 80003e4:	200000b4 	.word	0x200000b4

080003e8 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80003e8:	e7fe      	b.n	80003e8 <ADC1_2_IRQHandler>
	...

080003ec <EXTI0_IRQHandler>:
		break;
	}
}

void EXTI0_IRQHandler (void)
{
 80003ec:	b580      	push	{r7, lr}
 80003ee:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit Pending register
	SET_BIT(EXTI->PR,EXTI0);
 80003f0:	4b05      	ldr	r3, [pc, #20]	; (8000408 <EXTI0_IRQHandler+0x1c>)
 80003f2:	695b      	ldr	r3, [r3, #20]
 80003f4:	4a04      	ldr	r2, [pc, #16]	; (8000408 <EXTI0_IRQHandler+0x1c>)
 80003f6:	f043 0301 	orr.w	r3, r3, #1
 80003fa:	6153      	str	r3, [r2, #20]
	//EXTI->PR |= 1<<0;

	//IRQ callback
	call_back[EXTI0]();
 80003fc:	4b03      	ldr	r3, [pc, #12]	; (800040c <EXTI0_IRQHandler+0x20>)
 80003fe:	681b      	ldr	r3, [r3, #0]
 8000400:	4798      	blx	r3
}
 8000402:	bf00      	nop
 8000404:	bd80      	pop	{r7, pc}
 8000406:	bf00      	nop
 8000408:	40010400 	.word	0x40010400
 800040c:	2000001c 	.word	0x2000001c

08000410 <EXTI1_IRQHandler>:

void EXTI1_IRQHandler (void)
{
 8000410:	b580      	push	{r7, lr}
 8000412:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit Pending register
	SET_BIT(EXTI->PR,EXTI1);
 8000414:	4b05      	ldr	r3, [pc, #20]	; (800042c <EXTI1_IRQHandler+0x1c>)
 8000416:	695b      	ldr	r3, [r3, #20]
 8000418:	4a04      	ldr	r2, [pc, #16]	; (800042c <EXTI1_IRQHandler+0x1c>)
 800041a:	f043 0302 	orr.w	r3, r3, #2
 800041e:	6153      	str	r3, [r2, #20]
	//EXTI->PR |= 1<<1;

	//IRQ callback
	call_back[EXTI1]();
 8000420:	4b03      	ldr	r3, [pc, #12]	; (8000430 <EXTI1_IRQHandler+0x20>)
 8000422:	685b      	ldr	r3, [r3, #4]
 8000424:	4798      	blx	r3
}
 8000426:	bf00      	nop
 8000428:	bd80      	pop	{r7, pc}
 800042a:	bf00      	nop
 800042c:	40010400 	.word	0x40010400
 8000430:	2000001c 	.word	0x2000001c

08000434 <EXTI2_IRQHandler>:
void EXTI2_IRQHandler (void)
{
 8000434:	b580      	push	{r7, lr}
 8000436:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit Pending register
	SET_BIT(EXTI->PR,EXTI2);
 8000438:	4b05      	ldr	r3, [pc, #20]	; (8000450 <EXTI2_IRQHandler+0x1c>)
 800043a:	695b      	ldr	r3, [r3, #20]
 800043c:	4a04      	ldr	r2, [pc, #16]	; (8000450 <EXTI2_IRQHandler+0x1c>)
 800043e:	f043 0304 	orr.w	r3, r3, #4
 8000442:	6153      	str	r3, [r2, #20]
	//EXTI->PR |= 1<<2;

	//IRQ callback
	call_back[EXTI2]();
 8000444:	4b03      	ldr	r3, [pc, #12]	; (8000454 <EXTI2_IRQHandler+0x20>)
 8000446:	689b      	ldr	r3, [r3, #8]
 8000448:	4798      	blx	r3
}
 800044a:	bf00      	nop
 800044c:	bd80      	pop	{r7, pc}
 800044e:	bf00      	nop
 8000450:	40010400 	.word	0x40010400
 8000454:	2000001c 	.word	0x2000001c

08000458 <EXTI3_IRQHandler>:
void EXTI3_IRQHandler (void)
{
 8000458:	b580      	push	{r7, lr}
 800045a:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit Pending register
	SET_BIT(EXTI->PR,EXTI3);
 800045c:	4b05      	ldr	r3, [pc, #20]	; (8000474 <EXTI3_IRQHandler+0x1c>)
 800045e:	695b      	ldr	r3, [r3, #20]
 8000460:	4a04      	ldr	r2, [pc, #16]	; (8000474 <EXTI3_IRQHandler+0x1c>)
 8000462:	f043 0308 	orr.w	r3, r3, #8
 8000466:	6153      	str	r3, [r2, #20]
	//EXTI->PR |= 1<<3;

	//IRQ callback
	call_back[EXTI3]();
 8000468:	4b03      	ldr	r3, [pc, #12]	; (8000478 <EXTI3_IRQHandler+0x20>)
 800046a:	68db      	ldr	r3, [r3, #12]
 800046c:	4798      	blx	r3
}
 800046e:	bf00      	nop
 8000470:	bd80      	pop	{r7, pc}
 8000472:	bf00      	nop
 8000474:	40010400 	.word	0x40010400
 8000478:	2000001c 	.word	0x2000001c

0800047c <EXTI4_IRQHandler>:
void EXTI4_IRQHandler (void)
{
 800047c:	b580      	push	{r7, lr}
 800047e:	af00      	add	r7, sp, #0
	//cleared by writing 1 into the bit Pending register
	SET_BIT(EXTI->PR,EXTI4);
 8000480:	4b05      	ldr	r3, [pc, #20]	; (8000498 <EXTI4_IRQHandler+0x1c>)
 8000482:	695b      	ldr	r3, [r3, #20]
 8000484:	4a04      	ldr	r2, [pc, #16]	; (8000498 <EXTI4_IRQHandler+0x1c>)
 8000486:	f043 0310 	orr.w	r3, r3, #16
 800048a:	6153      	str	r3, [r2, #20]
	//EXTI->PR |= 1<<4;

	//IRQ callback
	call_back[EXTI4]();
 800048c:	4b03      	ldr	r3, [pc, #12]	; (800049c <EXTI4_IRQHandler+0x20>)
 800048e:	691b      	ldr	r3, [r3, #16]
 8000490:	4798      	blx	r3
}
 8000492:	bf00      	nop
 8000494:	bd80      	pop	{r7, pc}
 8000496:	bf00      	nop
 8000498:	40010400 	.word	0x40010400
 800049c:	2000001c 	.word	0x2000001c

080004a0 <EXTI9_5_IRQHandler>:
void EXTI9_5_IRQHandler (void)
{
 80004a0:	b580      	push	{r7, lr}
 80004a2:	af00      	add	r7, sp, #0
	if(EXTI->PR & 1<<5){SET_BIT(EXTI->PR,EXTI5);call_back[EXTI5]();}
 80004a4:	4b26      	ldr	r3, [pc, #152]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004a6:	695b      	ldr	r3, [r3, #20]
 80004a8:	f003 0320 	and.w	r3, r3, #32
 80004ac:	2b00      	cmp	r3, #0
 80004ae:	d008      	beq.n	80004c2 <EXTI9_5_IRQHandler+0x22>
 80004b0:	4b23      	ldr	r3, [pc, #140]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004b2:	695b      	ldr	r3, [r3, #20]
 80004b4:	4a22      	ldr	r2, [pc, #136]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004b6:	f043 0320 	orr.w	r3, r3, #32
 80004ba:	6153      	str	r3, [r2, #20]
 80004bc:	4b21      	ldr	r3, [pc, #132]	; (8000544 <EXTI9_5_IRQHandler+0xa4>)
 80004be:	695b      	ldr	r3, [r3, #20]
 80004c0:	4798      	blx	r3
	if(EXTI->PR & 1<<6){SET_BIT(EXTI->PR,EXTI6);call_back[EXTI6]();}
 80004c2:	4b1f      	ldr	r3, [pc, #124]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004c4:	695b      	ldr	r3, [r3, #20]
 80004c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80004ca:	2b00      	cmp	r3, #0
 80004cc:	d008      	beq.n	80004e0 <EXTI9_5_IRQHandler+0x40>
 80004ce:	4b1c      	ldr	r3, [pc, #112]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004d0:	695b      	ldr	r3, [r3, #20]
 80004d2:	4a1b      	ldr	r2, [pc, #108]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80004d8:	6153      	str	r3, [r2, #20]
 80004da:	4b1a      	ldr	r3, [pc, #104]	; (8000544 <EXTI9_5_IRQHandler+0xa4>)
 80004dc:	699b      	ldr	r3, [r3, #24]
 80004de:	4798      	blx	r3
	if(EXTI->PR & 1<<7){SET_BIT(EXTI->PR,EXTI7);call_back[EXTI7]();}
 80004e0:	4b17      	ldr	r3, [pc, #92]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004e2:	695b      	ldr	r3, [r3, #20]
 80004e4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80004e8:	2b00      	cmp	r3, #0
 80004ea:	d008      	beq.n	80004fe <EXTI9_5_IRQHandler+0x5e>
 80004ec:	4b14      	ldr	r3, [pc, #80]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004ee:	695b      	ldr	r3, [r3, #20]
 80004f0:	4a13      	ldr	r2, [pc, #76]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 80004f2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80004f6:	6153      	str	r3, [r2, #20]
 80004f8:	4b12      	ldr	r3, [pc, #72]	; (8000544 <EXTI9_5_IRQHandler+0xa4>)
 80004fa:	69db      	ldr	r3, [r3, #28]
 80004fc:	4798      	blx	r3
	if(EXTI->PR & 1<<8){SET_BIT(EXTI->PR,EXTI8);call_back[EXTI8]();}
 80004fe:	4b10      	ldr	r3, [pc, #64]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 8000500:	695b      	ldr	r3, [r3, #20]
 8000502:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000506:	2b00      	cmp	r3, #0
 8000508:	d008      	beq.n	800051c <EXTI9_5_IRQHandler+0x7c>
 800050a:	4b0d      	ldr	r3, [pc, #52]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 800050c:	695b      	ldr	r3, [r3, #20]
 800050e:	4a0c      	ldr	r2, [pc, #48]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 8000510:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000514:	6153      	str	r3, [r2, #20]
 8000516:	4b0b      	ldr	r3, [pc, #44]	; (8000544 <EXTI9_5_IRQHandler+0xa4>)
 8000518:	6a1b      	ldr	r3, [r3, #32]
 800051a:	4798      	blx	r3
	if(EXTI->PR & 1<<9){SET_BIT(EXTI->PR,EXTI9);call_back[EXTI9]();}
 800051c:	4b08      	ldr	r3, [pc, #32]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 800051e:	695b      	ldr	r3, [r3, #20]
 8000520:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000524:	2b00      	cmp	r3, #0
 8000526:	d008      	beq.n	800053a <EXTI9_5_IRQHandler+0x9a>
 8000528:	4b05      	ldr	r3, [pc, #20]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 800052a:	695b      	ldr	r3, [r3, #20]
 800052c:	4a04      	ldr	r2, [pc, #16]	; (8000540 <EXTI9_5_IRQHandler+0xa0>)
 800052e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000532:	6153      	str	r3, [r2, #20]
 8000534:	4b03      	ldr	r3, [pc, #12]	; (8000544 <EXTI9_5_IRQHandler+0xa4>)
 8000536:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000538:	4798      	blx	r3
}
 800053a:	bf00      	nop
 800053c:	bd80      	pop	{r7, pc}
 800053e:	bf00      	nop
 8000540:	40010400 	.word	0x40010400
 8000544:	2000001c 	.word	0x2000001c

08000548 <EXTI15_10_IRQHandler>:
void EXTI15_10_IRQHandler (void)
{
 8000548:	b580      	push	{r7, lr}
 800054a:	af00      	add	r7, sp, #0
	if(EXTI->PR & 1<<10){SET_BIT(EXTI->PR,EXTI10);call_back[EXTI10]();}
 800054c:	4b2d      	ldr	r3, [pc, #180]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800054e:	695b      	ldr	r3, [r3, #20]
 8000550:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000554:	2b00      	cmp	r3, #0
 8000556:	d008      	beq.n	800056a <EXTI15_10_IRQHandler+0x22>
 8000558:	4b2a      	ldr	r3, [pc, #168]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800055a:	695b      	ldr	r3, [r3, #20]
 800055c:	4a29      	ldr	r2, [pc, #164]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800055e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000562:	6153      	str	r3, [r2, #20]
 8000564:	4b28      	ldr	r3, [pc, #160]	; (8000608 <EXTI15_10_IRQHandler+0xc0>)
 8000566:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000568:	4798      	blx	r3
	if(EXTI->PR & 1<<11){SET_BIT(EXTI->PR,EXTI11);call_back[EXTI11]();}
 800056a:	4b26      	ldr	r3, [pc, #152]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800056c:	695b      	ldr	r3, [r3, #20]
 800056e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000572:	2b00      	cmp	r3, #0
 8000574:	d008      	beq.n	8000588 <EXTI15_10_IRQHandler+0x40>
 8000576:	4b23      	ldr	r3, [pc, #140]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 8000578:	695b      	ldr	r3, [r3, #20]
 800057a:	4a22      	ldr	r2, [pc, #136]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800057c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000580:	6153      	str	r3, [r2, #20]
 8000582:	4b21      	ldr	r3, [pc, #132]	; (8000608 <EXTI15_10_IRQHandler+0xc0>)
 8000584:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000586:	4798      	blx	r3
	if(EXTI->PR & 1<<12){SET_BIT(EXTI->PR,EXTI12);call_back[EXTI12]();}
 8000588:	4b1e      	ldr	r3, [pc, #120]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800058a:	695b      	ldr	r3, [r3, #20]
 800058c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000590:	2b00      	cmp	r3, #0
 8000592:	d008      	beq.n	80005a6 <EXTI15_10_IRQHandler+0x5e>
 8000594:	4b1b      	ldr	r3, [pc, #108]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 8000596:	695b      	ldr	r3, [r3, #20]
 8000598:	4a1a      	ldr	r2, [pc, #104]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 800059a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800059e:	6153      	str	r3, [r2, #20]
 80005a0:	4b19      	ldr	r3, [pc, #100]	; (8000608 <EXTI15_10_IRQHandler+0xc0>)
 80005a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80005a4:	4798      	blx	r3
	if(EXTI->PR & 1<<13){SET_BIT(EXTI->PR,EXTI13);call_back[EXTI13]();}
 80005a6:	4b17      	ldr	r3, [pc, #92]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005a8:	695b      	ldr	r3, [r3, #20]
 80005aa:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80005ae:	2b00      	cmp	r3, #0
 80005b0:	d008      	beq.n	80005c4 <EXTI15_10_IRQHandler+0x7c>
 80005b2:	4b14      	ldr	r3, [pc, #80]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005b4:	695b      	ldr	r3, [r3, #20]
 80005b6:	4a13      	ldr	r2, [pc, #76]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005b8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80005bc:	6153      	str	r3, [r2, #20]
 80005be:	4b12      	ldr	r3, [pc, #72]	; (8000608 <EXTI15_10_IRQHandler+0xc0>)
 80005c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80005c2:	4798      	blx	r3
	if(EXTI->PR & 1<<14){SET_BIT(EXTI->PR,EXTI14);call_back[EXTI14]();}
 80005c4:	4b0f      	ldr	r3, [pc, #60]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005c6:	695b      	ldr	r3, [r3, #20]
 80005c8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80005cc:	2b00      	cmp	r3, #0
 80005ce:	d008      	beq.n	80005e2 <EXTI15_10_IRQHandler+0x9a>
 80005d0:	4b0c      	ldr	r3, [pc, #48]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005d2:	695b      	ldr	r3, [r3, #20]
 80005d4:	4a0b      	ldr	r2, [pc, #44]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005d6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80005da:	6153      	str	r3, [r2, #20]
 80005dc:	4b0a      	ldr	r3, [pc, #40]	; (8000608 <EXTI15_10_IRQHandler+0xc0>)
 80005de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80005e0:	4798      	blx	r3
	if(EXTI->PR & 1<<15){SET_BIT(EXTI->PR,EXTI15);call_back[EXTI15]();}
 80005e2:	4b08      	ldr	r3, [pc, #32]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005e4:	695b      	ldr	r3, [r3, #20]
 80005e6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80005ea:	2b00      	cmp	r3, #0
 80005ec:	d008      	beq.n	8000600 <EXTI15_10_IRQHandler+0xb8>
 80005ee:	4b05      	ldr	r3, [pc, #20]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005f0:	695b      	ldr	r3, [r3, #20]
 80005f2:	4a04      	ldr	r2, [pc, #16]	; (8000604 <EXTI15_10_IRQHandler+0xbc>)
 80005f4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80005f8:	6153      	str	r3, [r2, #20]
 80005fa:	4b03      	ldr	r3, [pc, #12]	; (8000608 <EXTI15_10_IRQHandler+0xc0>)
 80005fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80005fe:	4798      	blx	r3
}
 8000600:	bf00      	nop
 8000602:	bd80      	pop	{r7, pc}
 8000604:	40010400 	.word	0x40010400
 8000608:	2000001c 	.word	0x2000001c

0800060c <Get_PinPostion>:
 *  Created on: Jul 3, 2024
 *      Author: ismail
 */
#include "GPIO.h"
uint8_t Get_PinPostion(uint16_t PinNumber)
{
 800060c:	b480      	push	{r7}
 800060e:	b083      	sub	sp, #12
 8000610:	af00      	add	r7, sp, #0
 8000612:	4603      	mov	r3, r0
 8000614:	80fb      	strh	r3, [r7, #6]
	switch(PinNumber)
 8000616:	88fb      	ldrh	r3, [r7, #6]
 8000618:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800061c:	f000 808f 	beq.w	800073e <Get_PinPostion+0x132>
 8000620:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8000624:	f300 808d 	bgt.w	8000742 <Get_PinPostion+0x136>
 8000628:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800062c:	f000 8085 	beq.w	800073a <Get_PinPostion+0x12e>
 8000630:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000634:	f300 8085 	bgt.w	8000742 <Get_PinPostion+0x136>
 8000638:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800063c:	d07b      	beq.n	8000736 <Get_PinPostion+0x12a>
 800063e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8000642:	dc7e      	bgt.n	8000742 <Get_PinPostion+0x136>
 8000644:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000648:	d073      	beq.n	8000732 <Get_PinPostion+0x126>
 800064a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800064e:	dc78      	bgt.n	8000742 <Get_PinPostion+0x136>
 8000650:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000654:	d06b      	beq.n	800072e <Get_PinPostion+0x122>
 8000656:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800065a:	dc72      	bgt.n	8000742 <Get_PinPostion+0x136>
 800065c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000660:	d063      	beq.n	800072a <Get_PinPostion+0x11e>
 8000662:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000666:	dc6c      	bgt.n	8000742 <Get_PinPostion+0x136>
 8000668:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800066c:	d05b      	beq.n	8000726 <Get_PinPostion+0x11a>
 800066e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000672:	dc66      	bgt.n	8000742 <Get_PinPostion+0x136>
 8000674:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000678:	d053      	beq.n	8000722 <Get_PinPostion+0x116>
 800067a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800067e:	dc60      	bgt.n	8000742 <Get_PinPostion+0x136>
 8000680:	2b80      	cmp	r3, #128	; 0x80
 8000682:	d05c      	beq.n	800073e <Get_PinPostion+0x132>
 8000684:	2b80      	cmp	r3, #128	; 0x80
 8000686:	dc5c      	bgt.n	8000742 <Get_PinPostion+0x136>
 8000688:	2b20      	cmp	r3, #32
 800068a:	dc47      	bgt.n	800071c <Get_PinPostion+0x110>
 800068c:	2b00      	cmp	r3, #0
 800068e:	dd58      	ble.n	8000742 <Get_PinPostion+0x136>
 8000690:	3b01      	subs	r3, #1
 8000692:	2b1f      	cmp	r3, #31
 8000694:	d855      	bhi.n	8000742 <Get_PinPostion+0x136>
 8000696:	a201      	add	r2, pc, #4	; (adr r2, 800069c <Get_PinPostion+0x90>)
 8000698:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800069c:	08000723 	.word	0x08000723
 80006a0:	08000727 	.word	0x08000727
 80006a4:	08000743 	.word	0x08000743
 80006a8:	0800072b 	.word	0x0800072b
 80006ac:	08000743 	.word	0x08000743
 80006b0:	08000743 	.word	0x08000743
 80006b4:	08000743 	.word	0x08000743
 80006b8:	0800072f 	.word	0x0800072f
 80006bc:	08000743 	.word	0x08000743
 80006c0:	08000743 	.word	0x08000743
 80006c4:	08000743 	.word	0x08000743
 80006c8:	08000743 	.word	0x08000743
 80006cc:	08000743 	.word	0x08000743
 80006d0:	08000743 	.word	0x08000743
 80006d4:	08000743 	.word	0x08000743
 80006d8:	08000733 	.word	0x08000733
 80006dc:	08000743 	.word	0x08000743
 80006e0:	08000743 	.word	0x08000743
 80006e4:	08000743 	.word	0x08000743
 80006e8:	08000743 	.word	0x08000743
 80006ec:	08000743 	.word	0x08000743
 80006f0:	08000743 	.word	0x08000743
 80006f4:	08000743 	.word	0x08000743
 80006f8:	08000743 	.word	0x08000743
 80006fc:	08000743 	.word	0x08000743
 8000700:	08000743 	.word	0x08000743
 8000704:	08000743 	.word	0x08000743
 8000708:	08000743 	.word	0x08000743
 800070c:	08000743 	.word	0x08000743
 8000710:	08000743 	.word	0x08000743
 8000714:	08000743 	.word	0x08000743
 8000718:	08000737 	.word	0x08000737
 800071c:	2b40      	cmp	r3, #64	; 0x40
 800071e:	d00c      	beq.n	800073a <Get_PinPostion+0x12e>
 8000720:	e00f      	b.n	8000742 <Get_PinPostion+0x136>
	{
	case GPIO_PIN_0:
	case GPIO_PIN_8:
		return 0;
 8000722:	2300      	movs	r3, #0
 8000724:	e00e      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_1:
	case GPIO_PIN_9:
		return 4;
 8000726:	2304      	movs	r3, #4
 8000728:	e00c      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_2:
	case GPIO_PIN_10:
		return 8;
 800072a:	2308      	movs	r3, #8
 800072c:	e00a      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_3:
	case GPIO_PIN_11:
		return 12;
 800072e:	230c      	movs	r3, #12
 8000730:	e008      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_4:
	case GPIO_PIN_12:
		return 16;
 8000732:	2310      	movs	r3, #16
 8000734:	e006      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_5:
	case GPIO_PIN_13:
		return 20;
 8000736:	2314      	movs	r3, #20
 8000738:	e004      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_6:
	case GPIO_PIN_14:
		return 24;
 800073a:	2318      	movs	r3, #24
 800073c:	e002      	b.n	8000744 <Get_PinPostion+0x138>
		break;

	case GPIO_PIN_7:
	case GPIO_PIN_15:
		return 28;
 800073e:	231c      	movs	r3, #28
 8000740:	e000      	b.n	8000744 <Get_PinPostion+0x138>
		break;
	}
	return 0;
 8000742:	2300      	movs	r3, #0
}
 8000744:	4618      	mov	r0, r3
 8000746:	370c      	adds	r7, #12
 8000748:	46bd      	mov	sp, r7
 800074a:	bc80      	pop	{r7}
 800074c:	4770      	bx	lr
 800074e:	bf00      	nop

08000750 <GPIO_Init>:
 * @retval 		-none
 * Note			-STM32F103C6 MCU has GPIO A,B,C,D,E Modules
 * 				 but LQFP48 Package has only GPIO A,B Part of C,D exported as external PINs from the MCU
================================================================**/
void GPIO_Init(GPIO_t *GPIOx,GPIO_Config_t *PinConfig)
{
 8000750:	b590      	push	{r4, r7, lr}
 8000752:	b085      	sub	sp, #20
 8000754:	af00      	add	r7, sp, #0
 8000756:	6078      	str	r0, [r7, #4]
 8000758:	6039      	str	r1, [r7, #0]
	// Port configuration register high (GPIOx_CRH) configure PINs from 0 >> 7
	// Port configuration register high (GPIOx_CRH) configure PINs from 8 >> 15
	volatile uint32_t *Config_Register = NULL;
 800075a:	2300      	movs	r3, #0
 800075c:	60bb      	str	r3, [r7, #8]
	uint8_t Pin_config = 0;
 800075e:	2300      	movs	r3, #0
 8000760:	73fb      	strb	r3, [r7, #15]
	//see if it's CRL or CRH
	Config_Register = (PinConfig->GPIO_PinNumber < GPIO_PIN_8)?	&GPIOx->CRL : &GPIOx->CRH;
 8000762:	683b      	ldr	r3, [r7, #0]
 8000764:	881b      	ldrh	r3, [r3, #0]
 8000766:	2bff      	cmp	r3, #255	; 0xff
 8000768:	d801      	bhi.n	800076e <GPIO_Init+0x1e>
 800076a:	687b      	ldr	r3, [r7, #4]
 800076c:	e001      	b.n	8000772 <GPIO_Init+0x22>
 800076e:	687b      	ldr	r3, [r7, #4]
 8000770:	3304      	adds	r3, #4
 8000772:	60bb      	str	r3, [r7, #8]
	//Reset CNF and MODE
	(*Config_Register) &= ~(0xf << Get_PinPostion(PinConfig->GPIO_PinNumber));	/*
 8000774:	683b      	ldr	r3, [r7, #0]
 8000776:	881b      	ldrh	r3, [r3, #0]
 8000778:	4618      	mov	r0, r3
 800077a:	f7ff ff47 	bl	800060c <Get_PinPostion>
 800077e:	4603      	mov	r3, r0
 8000780:	461a      	mov	r2, r3
 8000782:	230f      	movs	r3, #15
 8000784:	4093      	lsls	r3, r2
 8000786:	43da      	mvns	r2, r3
 8000788:	68bb      	ldr	r3, [r7, #8]
 800078a:	681b      	ldr	r3, [r3, #0]
 800078c:	401a      	ands	r2, r3
 800078e:	68bb      	ldr	r3, [r7, #8]
 8000790:	601a      	str	r2, [r3, #0]
	 * ------------------
	 * |  3	| 2 | 1	| 0	| //clear it to write what i want
	 * ------------------
	 */
	//see if the pin is Input or Output so that if it's output i put the speed with it if input then it's only mode
	if((PinConfig->GPIO_PinMode == GPIO_MODE_OUTPUT_PP)||(PinConfig->GPIO_PinMode == GPIO_MODE_OUTPUT_OD)||(PinConfig->GPIO_PinMode == GPIO_MODE_OUTPUT_AF_PP)||(PinConfig->GPIO_PinMode == GPIO_MODE_OUTPUT_AF_OD))
 8000792:	683b      	ldr	r3, [r7, #0]
 8000794:	885b      	ldrh	r3, [r3, #2]
 8000796:	2b04      	cmp	r3, #4
 8000798:	d00b      	beq.n	80007b2 <GPIO_Init+0x62>
 800079a:	683b      	ldr	r3, [r7, #0]
 800079c:	885b      	ldrh	r3, [r3, #2]
 800079e:	2b05      	cmp	r3, #5
 80007a0:	d007      	beq.n	80007b2 <GPIO_Init+0x62>
 80007a2:	683b      	ldr	r3, [r7, #0]
 80007a4:	885b      	ldrh	r3, [r3, #2]
 80007a6:	2b06      	cmp	r3, #6
 80007a8:	d003      	beq.n	80007b2 <GPIO_Init+0x62>
 80007aa:	683b      	ldr	r3, [r7, #0]
 80007ac:	885b      	ldrh	r3, [r3, #2]
 80007ae:	2b07      	cmp	r3, #7
 80007b0:	d11c      	bne.n	80007ec <GPIO_Init+0x9c>
		 * 00: General purpose output push-pull		--> GPIO_MODE_OUTPUT_PP		>>	0x00000004u
		 * 01: General purpose output Open-drain	--> GPIO_MODE_OUTPUT_OD		>>	0x00000005u
		 * 10: Alternate function output Push-pull	--> GPIO_MODE_OUTPUT_AF_PP	>>	0x00000006u
		 * 11: Alternate function output Open-drain	--> GPIO_MODE_OUTPUT_AF_OD	>>	0x00000007u
		 */
		Pin_config = ( ( ( (PinConfig->GPIO_PinMode - 4 ) << 2 ) | (PinConfig->GPIO_PinSpeed)) & 0x0F );
 80007b2:	683b      	ldr	r3, [r7, #0]
 80007b4:	885b      	ldrh	r3, [r3, #2]
 80007b6:	3b04      	subs	r3, #4
 80007b8:	009b      	lsls	r3, r3, #2
 80007ba:	b25a      	sxtb	r2, r3
 80007bc:	683b      	ldr	r3, [r7, #0]
 80007be:	889b      	ldrh	r3, [r3, #4]
 80007c0:	b25b      	sxtb	r3, r3
 80007c2:	4313      	orrs	r3, r2
 80007c4:	b25b      	sxtb	r3, r3
 80007c6:	b2db      	uxtb	r3, r3
 80007c8:	f003 030f 	and.w	r3, r3, #15
 80007cc:	73fb      	strb	r3, [r7, #15]
		(*Config_Register) |= ( Pin_config << Get_PinPostion(PinConfig->GPIO_PinNumber) );
 80007ce:	7bfc      	ldrb	r4, [r7, #15]
 80007d0:	683b      	ldr	r3, [r7, #0]
 80007d2:	881b      	ldrh	r3, [r3, #0]
 80007d4:	4618      	mov	r0, r3
 80007d6:	f7ff ff19 	bl	800060c <Get_PinPostion>
 80007da:	4603      	mov	r3, r0
 80007dc:	fa04 f203 	lsl.w	r2, r4, r3
 80007e0:	68bb      	ldr	r3, [r7, #8]
 80007e2:	681b      	ldr	r3, [r3, #0]
 80007e4:	431a      	orrs	r2, r3
 80007e6:	68bb      	ldr	r3, [r7, #8]
 80007e8:	601a      	str	r2, [r3, #0]
 80007ea:	e072      	b.n	80008d2 <GPIO_Init+0x182>
		 * 11: Input with PU or PD	--> GPIO_MODE_INPUT_PU
		 * //the only thing to diff from PU or PD
		 * 		PU: ODR --> 1
		 * 		PD: ODR --> 0
		 */
		if((PinConfig->GPIO_PinMode  == GPIO_MODE_INPUT_FLO) || (PinConfig->GPIO_PinMode  == GPIO_MODE_ANALOG))
 80007ec:	683b      	ldr	r3, [r7, #0]
 80007ee:	885b      	ldrh	r3, [r3, #2]
 80007f0:	2b01      	cmp	r3, #1
 80007f2:	d003      	beq.n	80007fc <GPIO_Init+0xac>
 80007f4:	683b      	ldr	r3, [r7, #0]
 80007f6:	885b      	ldrh	r3, [r3, #2]
 80007f8:	2b00      	cmp	r3, #0
 80007fa:	d115      	bne.n	8000828 <GPIO_Init+0xd8>
		{
			Pin_config = ((((PinConfig ->GPIO_PinMode) << 2) | (0)) & 0x0F );
 80007fc:	683b      	ldr	r3, [r7, #0]
 80007fe:	885b      	ldrh	r3, [r3, #2]
 8000800:	009b      	lsls	r3, r3, #2
 8000802:	b2db      	uxtb	r3, r3
 8000804:	f003 030f 	and.w	r3, r3, #15
 8000808:	73fb      	strb	r3, [r7, #15]
			(*Config_Register) |= ( Pin_config << Get_PinPostion(PinConfig->GPIO_PinNumber) );
 800080a:	7bfc      	ldrb	r4, [r7, #15]
 800080c:	683b      	ldr	r3, [r7, #0]
 800080e:	881b      	ldrh	r3, [r3, #0]
 8000810:	4618      	mov	r0, r3
 8000812:	f7ff fefb 	bl	800060c <Get_PinPostion>
 8000816:	4603      	mov	r3, r0
 8000818:	fa04 f203 	lsl.w	r2, r4, r3
 800081c:	68bb      	ldr	r3, [r7, #8]
 800081e:	681b      	ldr	r3, [r3, #0]
 8000820:	431a      	orrs	r2, r3
 8000822:	68bb      	ldr	r3, [r7, #8]
 8000824:	601a      	str	r2, [r3, #0]
 8000826:	e054      	b.n	80008d2 <GPIO_Init+0x182>
		}
		else if((PinConfig->GPIO_PinMode  == GPIO_MODE_INPUT_PU)||(PinConfig->GPIO_PinMode  == GPIO_MODE_INPUT_PD ))
 8000828:	683b      	ldr	r3, [r7, #0]
 800082a:	885b      	ldrh	r3, [r3, #2]
 800082c:	2b02      	cmp	r3, #2
 800082e:	d003      	beq.n	8000838 <GPIO_Init+0xe8>
 8000830:	683b      	ldr	r3, [r7, #0]
 8000832:	885b      	ldrh	r3, [r3, #2]
 8000834:	2b03      	cmp	r3, #3
 8000836:	d135      	bne.n	80008a4 <GPIO_Init+0x154>
		{
			switch(PinConfig->GPIO_PinMode)
 8000838:	683b      	ldr	r3, [r7, #0]
 800083a:	885b      	ldrh	r3, [r3, #2]
 800083c:	2b02      	cmp	r3, #2
 800083e:	d002      	beq.n	8000846 <GPIO_Init+0xf6>
 8000840:	2b03      	cmp	r3, #3
 8000842:	d00f      	beq.n	8000864 <GPIO_Init+0x114>
 8000844:	e01f      	b.n	8000886 <GPIO_Init+0x136>
			{
			case  GPIO_MODE_INPUT_PU :
				GPIOx->ODR |= (PinConfig->GPIO_PinNumber);
 8000846:	687b      	ldr	r3, [r7, #4]
 8000848:	68db      	ldr	r3, [r3, #12]
 800084a:	683a      	ldr	r2, [r7, #0]
 800084c:	8812      	ldrh	r2, [r2, #0]
 800084e:	431a      	orrs	r2, r3
 8000850:	687b      	ldr	r3, [r7, #4]
 8000852:	60da      	str	r2, [r3, #12]
				Pin_config = (((PinConfig->GPIO_PinMode << 2 )|(0))&0x0F);
 8000854:	683b      	ldr	r3, [r7, #0]
 8000856:	885b      	ldrh	r3, [r3, #2]
 8000858:	009b      	lsls	r3, r3, #2
 800085a:	b2db      	uxtb	r3, r3
 800085c:	f003 030f 	and.w	r3, r3, #15
 8000860:	73fb      	strb	r3, [r7, #15]
				break;
 8000862:	e010      	b.n	8000886 <GPIO_Init+0x136>
			case GPIO_MODE_INPUT_PD :
				GPIOx->ODR &= ~(PinConfig->GPIO_PinNumber);
 8000864:	687b      	ldr	r3, [r7, #4]
 8000866:	68db      	ldr	r3, [r3, #12]
 8000868:	683a      	ldr	r2, [r7, #0]
 800086a:	8812      	ldrh	r2, [r2, #0]
 800086c:	43d2      	mvns	r2, r2
 800086e:	401a      	ands	r2, r3
 8000870:	687b      	ldr	r3, [r7, #4]
 8000872:	60da      	str	r2, [r3, #12]
				Pin_config = ((((PinConfig->GPIO_PinMode-1) << 2 )|(0))&0x0F);
 8000874:	683b      	ldr	r3, [r7, #0]
 8000876:	885b      	ldrh	r3, [r3, #2]
 8000878:	3b01      	subs	r3, #1
 800087a:	009b      	lsls	r3, r3, #2
 800087c:	b2db      	uxtb	r3, r3
 800087e:	f003 030f 	and.w	r3, r3, #15
 8000882:	73fb      	strb	r3, [r7, #15]
				break;
 8000884:	bf00      	nop
			}
			( *Config_Register ) |= ( Pin_config << Get_PinPostion(PinConfig->GPIO_PinNumber) );
 8000886:	7bfc      	ldrb	r4, [r7, #15]
 8000888:	683b      	ldr	r3, [r7, #0]
 800088a:	881b      	ldrh	r3, [r3, #0]
 800088c:	4618      	mov	r0, r3
 800088e:	f7ff febd 	bl	800060c <Get_PinPostion>
 8000892:	4603      	mov	r3, r0
 8000894:	fa04 f203 	lsl.w	r2, r4, r3
 8000898:	68bb      	ldr	r3, [r7, #8]
 800089a:	681b      	ldr	r3, [r3, #0]
 800089c:	431a      	orrs	r2, r3
 800089e:	68bb      	ldr	r3, [r7, #8]
 80008a0:	601a      	str	r2, [r3, #0]
 80008a2:	e016      	b.n	80008d2 <GPIO_Init+0x182>
		}
		else
		{ 	//pin is alternative input (same as input floating)
			Pin_config = ( (((PinConfig->GPIO_PinMode-7) << 2) | (0)) & 0x0F	);
 80008a4:	683b      	ldr	r3, [r7, #0]
 80008a6:	885b      	ldrh	r3, [r3, #2]
 80008a8:	3b07      	subs	r3, #7
 80008aa:	009b      	lsls	r3, r3, #2
 80008ac:	b2db      	uxtb	r3, r3
 80008ae:	f003 030f 	and.w	r3, r3, #15
 80008b2:	73fb      	strb	r3, [r7, #15]
			(*Config_Register) |= ( Pin_config << Get_PinPostion(PinConfig->GPIO_PinNumber) );
 80008b4:	7bfc      	ldrb	r4, [r7, #15]
 80008b6:	683b      	ldr	r3, [r7, #0]
 80008b8:	881b      	ldrh	r3, [r3, #0]
 80008ba:	4618      	mov	r0, r3
 80008bc:	f7ff fea6 	bl	800060c <Get_PinPostion>
 80008c0:	4603      	mov	r3, r0
 80008c2:	fa04 f203 	lsl.w	r2, r4, r3
 80008c6:	68bb      	ldr	r3, [r7, #8]
 80008c8:	681b      	ldr	r3, [r3, #0]
 80008ca:	431a      	orrs	r2, r3
 80008cc:	68bb      	ldr	r3, [r7, #8]
 80008ce:	601a      	str	r2, [r3, #0]

		}
	}
}
 80008d0:	bf00      	nop
 80008d2:	bf00      	nop
 80008d4:	3714      	adds	r7, #20
 80008d6:	46bd      	mov	sp, r7
 80008d8:	bd90      	pop	{r4, r7, pc}
	...

080008dc <I2C_Init>:
 * @retval 			- None
 * Note 			- Supported for I2C SM mode only
 * 					- Support only 7-bit address mode
 */
void I2C_Init(I2C_t *I2Cx, I2C_Config_t *I2C_Config)
{
 80008dc:	b5b0      	push	{r4, r5, r7, lr}
 80008de:	b086      	sub	sp, #24
 80008e0:	af00      	add	r7, sp, #0
 80008e2:	6078      	str	r0, [r7, #4]
 80008e4:	6039      	str	r1, [r7, #0]
	uint16_t Temp = 0 , Frequency = 0, Result = 0;
 80008e6:	2300      	movs	r3, #0
 80008e8:	82fb      	strh	r3, [r7, #22]
 80008ea:	2300      	movs	r3, #0
 80008ec:	82bb      	strh	r3, [r7, #20]
 80008ee:	2300      	movs	r3, #0
 80008f0:	827b      	strh	r3, [r7, #18]
	uint32_t Pclk1 = 0;
 80008f2:	2300      	movs	r3, #0
 80008f4:	60fb      	str	r3, [r7, #12]

	// Enable the RCC Clock
	if(I2Cx == I2C1)
 80008f6:	687b      	ldr	r3, [r7, #4]
 80008f8:	4a7b      	ldr	r2, [pc, #492]	; (8000ae8 <I2C_Init+0x20c>)
 80008fa:	4293      	cmp	r3, r2
 80008fc:	d112      	bne.n	8000924 <I2C_Init+0x48>
	{
		// If I2C1 Put all configurations in the global configuration
		Global_I2C_Config[0] = *I2C_Config;
 80008fe:	4a7b      	ldr	r2, [pc, #492]	; (8000aec <I2C_Init+0x210>)
 8000900:	683b      	ldr	r3, [r7, #0]
 8000902:	4614      	mov	r4, r2
 8000904:	461d      	mov	r5, r3
 8000906:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000908:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800090a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800090c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800090e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000912:	e884 0003 	stmia.w	r4, {r0, r1}

		// Open the I2C1 RCC Clock
		RCC_I2C1_CLK_EN();
 8000916:	4b76      	ldr	r3, [pc, #472]	; (8000af0 <I2C_Init+0x214>)
 8000918:	69db      	ldr	r3, [r3, #28]
 800091a:	4a75      	ldr	r2, [pc, #468]	; (8000af0 <I2C_Init+0x214>)
 800091c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000920:	61d3      	str	r3, [r2, #28]
 8000922:	e016      	b.n	8000952 <I2C_Init+0x76>
	}
	else if(I2Cx == I2C2)
 8000924:	687b      	ldr	r3, [r7, #4]
 8000926:	4a73      	ldr	r2, [pc, #460]	; (8000af4 <I2C_Init+0x218>)
 8000928:	4293      	cmp	r3, r2
 800092a:	d112      	bne.n	8000952 <I2C_Init+0x76>
	{
		// If I2C2 Put all configurations in the global configuration
		Global_I2C_Config[1] = *I2C_Config;
 800092c:	4b6f      	ldr	r3, [pc, #444]	; (8000aec <I2C_Init+0x210>)
 800092e:	683a      	ldr	r2, [r7, #0]
 8000930:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8000934:	4615      	mov	r5, r2
 8000936:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000938:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800093a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800093c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800093e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000942:	e884 0003 	stmia.w	r4, {r0, r1}

		// Open the I2C2 RCC Clock
		RCC_I2C2_CLK_EN();
 8000946:	4b6a      	ldr	r3, [pc, #424]	; (8000af0 <I2C_Init+0x214>)
 8000948:	69db      	ldr	r3, [r3, #28]
 800094a:	4a69      	ldr	r2, [pc, #420]	; (8000af0 <I2C_Init+0x214>)
 800094c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000950:	61d3      	str	r3, [r2, #28]
	}

	// Set I2C Mode
	if(I2C_Config->I2C_Mode == I2C_MODE_I2C)
 8000952:	683b      	ldr	r3, [r7, #0]
 8000954:	691b      	ldr	r3, [r3, #16]
 8000956:	2b00      	cmp	r3, #0
 8000958:	d17f      	bne.n	8000a5a <I2C_Init+0x17e>
		//     Initialize Timing
		/*
		 * --- I2C_CR2 -> Bits 5:0 FREQ[5:0]: Peripheral clock frequency
		 */

		Temp = I2Cx->CR2;
 800095a:	687b      	ldr	r3, [r7, #4]
 800095c:	685b      	ldr	r3, [r3, #4]
 800095e:	82fb      	strh	r3, [r7, #22]

		// Clear frequency
		Temp &= ~(I2C_CR2_FREQ_Msk); // (0x3FUL << 0) clear first 5bits
 8000960:	8afb      	ldrh	r3, [r7, #22]
 8000962:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8000966:	82fb      	strh	r3, [r7, #22]

		// Get Pclk1 frequency value
		Pclk1 = RCC_Get_PCLK1_Frequency();
 8000968:	f000 fc08 	bl	800117c <RCC_Get_PCLK1_Frequency>
 800096c:	60f8      	str	r0, [r7, #12]

		// Set frequency bits depending in Pclk1 value
		Frequency = (uint16_t)(Pclk1/1000000);
 800096e:	68fb      	ldr	r3, [r7, #12]
 8000970:	4a61      	ldr	r2, [pc, #388]	; (8000af8 <I2C_Init+0x21c>)
 8000972:	fba2 2303 	umull	r2, r3, r2, r3
 8000976:	0c9b      	lsrs	r3, r3, #18
 8000978:	82bb      	strh	r3, [r7, #20]

		// Move the configuration in the temp to set it in the CR2 register
		Temp |= Frequency;
 800097a:	8afa      	ldrh	r2, [r7, #22]
 800097c:	8abb      	ldrh	r3, [r7, #20]
 800097e:	4313      	orrs	r3, r2
 8000980:	82fb      	strh	r3, [r7, #22]
		I2Cx->CR2 = Temp;
 8000982:	8afa      	ldrh	r2, [r7, #22]
 8000984:	687b      	ldr	r3, [r7, #4]
 8000986:	605a      	str	r2, [r3, #4]

		// Configure CCR register

		// 7. Disable I2C peripheral
		I2Cx->CR1 &= ~(I2C_CR1_PE);
 8000988:	687b      	ldr	r3, [r7, #4]
 800098a:	681b      	ldr	r3, [r3, #0]
 800098c:	f023 0201 	bic.w	r2, r3, #1
 8000990:	687b      	ldr	r3, [r7, #4]
 8000992:	601a      	str	r2, [r3, #0]

		// Put the temp register with zero
		Temp = 0;
 8000994:	2300      	movs	r3, #0
 8000996:	82fb      	strh	r3, [r7, #22]

		// Configure the speed in the standard mode / Fast Mode
		if((I2C_Config->Clock_Speed == I2C_CLOCK_SPEED_50KHZ)||(I2C_Config->Clock_Speed == I2C_CLOCK_SPEED_100KHZ))
 8000998:	683b      	ldr	r3, [r7, #0]
 800099a:	681b      	ldr	r3, [r3, #0]
 800099c:	f24c 3250 	movw	r2, #50000	; 0xc350
 80009a0:	4293      	cmp	r3, r2
 80009a2:	d004      	beq.n	80009ae <I2C_Init+0xd2>
 80009a4:	683b      	ldr	r3, [r7, #0]
 80009a6:	681b      	ldr	r3, [r3, #0]
 80009a8:	4a54      	ldr	r2, [pc, #336]	; (8000afc <I2C_Init+0x220>)
 80009aa:	4293      	cmp	r3, r2
 80009ac:	d112      	bne.n	80009d4 <I2C_Init+0xf8>
			/*
			 * Tclk / 2 = CCR * Tpclk1
			 * CCR = Tclk / (2 * Tpclk1)
			 * CCR = Fpclk / (2 * I2C_ClockFrequency)
			 */
			Result = (uint16_t)(Pclk1/(I2C_Config->Clock_Speed << 1));//shift left = *2
 80009ae:	683b      	ldr	r3, [r7, #0]
 80009b0:	681b      	ldr	r3, [r3, #0]
 80009b2:	005b      	lsls	r3, r3, #1
 80009b4:	68fa      	ldr	r2, [r7, #12]
 80009b6:	fbb2 f3f3 	udiv	r3, r2, r3
 80009ba:	827b      	strh	r3, [r7, #18]

			// Move the configuration in the temp to set it in the CCR register
			Temp |= Result;
 80009bc:	8afa      	ldrh	r2, [r7, #22]
 80009be:	8a7b      	ldrh	r3, [r7, #18]
 80009c0:	4313      	orrs	r3, r2
 80009c2:	82fb      	strh	r3, [r7, #22]
			I2Cx->CCR = Temp;
 80009c4:	8afa      	ldrh	r2, [r7, #22]
 80009c6:	687b      	ldr	r3, [r7, #4]
 80009c8:	61da      	str	r2, [r3, #28]
			 * For instance: in Sm mode, the maximum allowed SCL rise time is 1000 ns.
			 * If, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to 0x08 and TPCLK1 = 125 ns
			 * therefore the TRISE[5:0] bits must be programmed with 09h.
			 * (1000 ns / 125 ns = 8 + 1)
			 */
			I2Cx->TRISE = Frequency + 1;
 80009ca:	8abb      	ldrh	r3, [r7, #20]
 80009cc:	3301      	adds	r3, #1
 80009ce:	461a      	mov	r2, r3
 80009d0:	687b      	ldr	r3, [r7, #4]
 80009d2:	621a      	str	r2, [r3, #32]
		}
		// ConfigCR1register

		// Get the I2C CR1 value
		Temp = I2Cx->CR1;
 80009d4:	687b      	ldr	r3, [r7, #4]
 80009d6:	681b      	ldr	r3, [r3, #0]
 80009d8:	82fb      	strh	r3, [r7, #22]

		// Set All configuration to the temp register and put it in CR1
		Temp |= (uint16_t)(I2C_Config->ACK_Control | I2C_Config->General_Call | I2C_Config->I2C_Mode | I2C_Config->Stretch_Mode);
 80009da:	683b      	ldr	r3, [r7, #0]
 80009dc:	695b      	ldr	r3, [r3, #20]
 80009de:	b29a      	uxth	r2, r3
 80009e0:	683b      	ldr	r3, [r7, #0]
 80009e2:	689b      	ldr	r3, [r3, #8]
 80009e4:	b29b      	uxth	r3, r3
 80009e6:	4313      	orrs	r3, r2
 80009e8:	b29a      	uxth	r2, r3
 80009ea:	683b      	ldr	r3, [r7, #0]
 80009ec:	691b      	ldr	r3, [r3, #16]
 80009ee:	b29b      	uxth	r3, r3
 80009f0:	4313      	orrs	r3, r2
 80009f2:	b29a      	uxth	r2, r3
 80009f4:	683b      	ldr	r3, [r7, #0]
 80009f6:	685b      	ldr	r3, [r3, #4]
 80009f8:	b29b      	uxth	r3, r3
 80009fa:	4313      	orrs	r3, r2
 80009fc:	b29a      	uxth	r2, r3
 80009fe:	8afb      	ldrh	r3, [r7, #22]
 8000a00:	4313      	orrs	r3, r2
 8000a02:	82fb      	strh	r3, [r7, #22]
		I2Cx->CR1 = Temp;
 8000a04:	8afa      	ldrh	r2, [r7, #22]
 8000a06:	687b      	ldr	r3, [r7, #4]
 8000a08:	601a      	str	r2, [r3, #0]

		// Config OAR registers

		// Put the temp register with zero
		Temp = 0;
 8000a0a:	2300      	movs	r3, #0
 8000a0c:	82fb      	strh	r3, [r7, #22]

		// Check the Slave_Address type
		if(I2C_Config->Slave_Address.Enable_Dual_Address == 1)
 8000a0e:	683b      	ldr	r3, [r7, #0]
 8000a10:	699b      	ldr	r3, [r3, #24]
 8000a12:	2b01      	cmp	r3, #1
 8000a14:	d10d      	bne.n	8000a32 <I2C_Init+0x156>
		{
			// Enable the Dual addressing mode
			Temp = I2C_OAR2_ENDUAL;
 8000a16:	2301      	movs	r3, #1
 8000a18:	82fb      	strh	r3, [r7, #22]
			// Put the input Second address form the user to the register
			/*
			 * Bits 7:1 ADD2[7:1]: Interface address
			 * 		bits 7:1 of address in dual addressing mode
			 */
			Temp |= I2C_Config->Slave_Address.Slave_Second_Address << I2C_OAR2_ADD2_Pos; // Shifting with the first bit in the register
 8000a1a:	683b      	ldr	r3, [r7, #0]
 8000a1c:	7f5b      	ldrb	r3, [r3, #29]
 8000a1e:	005b      	lsls	r3, r3, #1
 8000a20:	b21a      	sxth	r2, r3
 8000a22:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8000a26:	4313      	orrs	r3, r2
 8000a28:	b21b      	sxth	r3, r3
 8000a2a:	82fb      	strh	r3, [r7, #22]

			// Set the "I2C_OAR2" register with our new value
			I2Cx->OAR2 = Temp;
 8000a2c:	8afa      	ldrh	r2, [r7, #22]
 8000a2e:	687b      	ldr	r3, [r7, #4]
 8000a30:	60da      	str	r2, [r3, #12]
		}

		// Put the temp register with zero
		Temp = 0;
 8000a32:	2300      	movs	r3, #0
 8000a34:	82fb      	strh	r3, [r7, #22]

		// Put the input First address form the user to the register
		Temp |= I2C_Config->Slave_Address.Slave_First_Address << 1 ;
 8000a36:	683b      	ldr	r3, [r7, #0]
 8000a38:	7f1b      	ldrb	r3, [r3, #28]
 8000a3a:	005b      	lsls	r3, r3, #1
 8000a3c:	b21a      	sxth	r2, r3
 8000a3e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8000a42:	4313      	orrs	r3, r2
 8000a44:	b21b      	sxth	r3, r3
 8000a46:	82fb      	strh	r3, [r7, #22]

		// Configure ADDMODE Addressing mode (slave mode)
		Temp |= I2C_Config->Slave_Address.Slave_Address_Mode ;
 8000a48:	683b      	ldr	r3, [r7, #0]
 8000a4a:	6a1b      	ldr	r3, [r3, #32]
 8000a4c:	b29a      	uxth	r2, r3
 8000a4e:	8afb      	ldrh	r3, [r7, #22]
 8000a50:	4313      	orrs	r3, r2
 8000a52:	82fb      	strh	r3, [r7, #22]

		// Set the "I2C_OAR1" register with Temp
		I2Cx->OAR1 = Temp;
 8000a54:	8afa      	ldrh	r2, [r7, #22]
 8000a56:	687b      	ldr	r3, [r7, #4]
 8000a58:	609a      	str	r2, [r3, #8]
	}

	// Interrupt mode  works in (Slave Mode)
	if(I2C_Config->Slave_CallBack != NULL) // That enable slave IRQ states mode
 8000a5a:	683b      	ldr	r3, [r7, #0]
 8000a5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000a5e:	2b00      	cmp	r3, #0
 8000a60:	d038      	beq.n	8000ad4 <I2C_Init+0x1f8>
	{
		// Enable IRQ
		I2Cx->CR2 |= (I2C_CR2_ITERREN); // Error interrupt enable
 8000a62:	687b      	ldr	r3, [r7, #4]
 8000a64:	685b      	ldr	r3, [r3, #4]
 8000a66:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8000a6a:	687b      	ldr	r3, [r7, #4]
 8000a6c:	605a      	str	r2, [r3, #4]
		I2Cx->CR2 |= (I2C_CR2_ITEVTEN); // Event interrupt enable
 8000a6e:	687b      	ldr	r3, [r7, #4]
 8000a70:	685b      	ldr	r3, [r3, #4]
 8000a72:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8000a76:	687b      	ldr	r3, [r7, #4]
 8000a78:	605a      	str	r2, [r3, #4]
		I2Cx->CR2 |= (I2C_CR2_ITBUFEN); // Buffer interrupt enable
 8000a7a:	687b      	ldr	r3, [r7, #4]
 8000a7c:	685b      	ldr	r3, [r3, #4]
 8000a7e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8000a82:	687b      	ldr	r3, [r7, #4]
 8000a84:	605a      	str	r2, [r3, #4]

		// Enable IRQ in NVIC
		if(I2Cx == I2C1)
 8000a86:	687b      	ldr	r3, [r7, #4]
 8000a88:	4a17      	ldr	r2, [pc, #92]	; (8000ae8 <I2C_Init+0x20c>)
 8000a8a:	4293      	cmp	r3, r2
 8000a8c:	d10c      	bne.n	8000aa8 <I2C_Init+0x1cc>
		{
			NVIC_IRQ31_I2C1_EV_Enable();
 8000a8e:	4b1c      	ldr	r3, [pc, #112]	; (8000b00 <I2C_Init+0x224>)
 8000a90:	681b      	ldr	r3, [r3, #0]
 8000a92:	4a1b      	ldr	r2, [pc, #108]	; (8000b00 <I2C_Init+0x224>)
 8000a94:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a98:	6013      	str	r3, [r2, #0]
			NVIC_IRQ32_I2C1_ER_Enable();
 8000a9a:	4b1a      	ldr	r3, [pc, #104]	; (8000b04 <I2C_Init+0x228>)
 8000a9c:	681b      	ldr	r3, [r3, #0]
 8000a9e:	4a19      	ldr	r2, [pc, #100]	; (8000b04 <I2C_Init+0x228>)
 8000aa0:	f043 0301 	orr.w	r3, r3, #1
 8000aa4:	6013      	str	r3, [r2, #0]
 8000aa6:	e00f      	b.n	8000ac8 <I2C_Init+0x1ec>
		}
		else if (I2Cx == I2C2)
 8000aa8:	687b      	ldr	r3, [r7, #4]
 8000aaa:	4a12      	ldr	r2, [pc, #72]	; (8000af4 <I2C_Init+0x218>)
 8000aac:	4293      	cmp	r3, r2
 8000aae:	d10b      	bne.n	8000ac8 <I2C_Init+0x1ec>
		{
			NVIC_IRQ33_I2C2_EV_Enable();
 8000ab0:	4b14      	ldr	r3, [pc, #80]	; (8000b04 <I2C_Init+0x228>)
 8000ab2:	681b      	ldr	r3, [r3, #0]
 8000ab4:	4a13      	ldr	r2, [pc, #76]	; (8000b04 <I2C_Init+0x228>)
 8000ab6:	f043 0302 	orr.w	r3, r3, #2
 8000aba:	6013      	str	r3, [r2, #0]
			NVIC_IRQ34_I2C2_ER_Enable();
 8000abc:	4b11      	ldr	r3, [pc, #68]	; (8000b04 <I2C_Init+0x228>)
 8000abe:	681b      	ldr	r3, [r3, #0]
 8000ac0:	4a10      	ldr	r2, [pc, #64]	; (8000b04 <I2C_Init+0x228>)
 8000ac2:	f043 0304 	orr.w	r3, r3, #4
 8000ac6:	6013      	str	r3, [r2, #0]
		}

		// Put the status registers with zero
		I2Cx->SR1 = 0;
 8000ac8:	687b      	ldr	r3, [r7, #4]
 8000aca:	2200      	movs	r2, #0
 8000acc:	615a      	str	r2, [r3, #20]
		I2Cx->SR2 = 0;
 8000ace:	687b      	ldr	r3, [r7, #4]
 8000ad0:	2200      	movs	r2, #0
 8000ad2:	619a      	str	r2, [r3, #24]
	}

	// Enable I2C peripheral
	I2Cx->CR1 |= I2C_CR1_PE;
 8000ad4:	687b      	ldr	r3, [r7, #4]
 8000ad6:	681b      	ldr	r3, [r3, #0]
 8000ad8:	f043 0201 	orr.w	r2, r3, #1
 8000adc:	687b      	ldr	r3, [r7, #4]
 8000ade:	601a      	str	r2, [r3, #0]
}
 8000ae0:	bf00      	nop
 8000ae2:	3718      	adds	r7, #24
 8000ae4:	46bd      	mov	sp, r7
 8000ae6:	bdb0      	pop	{r4, r5, r7, pc}
 8000ae8:	40005400 	.word	0x40005400
 8000aec:	20000058 	.word	0x20000058
 8000af0:	40021000 	.word	0x40021000
 8000af4:	40005800 	.word	0x40005800
 8000af8:	431bde83 	.word	0x431bde83
 8000afc:	000186a0 	.word	0x000186a0
 8000b00:	e000e100 	.word	0xe000e100
 8000b04:	e000e104 	.word	0xe000e104

08000b08 <I2C_GPIO_SetPins>:
 * @param [in] 		- I2Cx : where x can be (1..2 depending on device used) to select I2C peripheral
 * @retval 			- None
 * Note 			- Supported for I2C SM MODE only
 */
void I2C_GPIO_SetPins(I2C_t *I2Cx)
{
 8000b08:	b580      	push	{r7, lr}
 8000b0a:	b084      	sub	sp, #16
 8000b0c:	af00      	add	r7, sp, #0
 8000b0e:	6078      	str	r0, [r7, #4]
	GPIO_Config_t Pin_Config;
	if(I2Cx == I2C1)
 8000b10:	687b      	ldr	r3, [r7, #4]
 8000b12:	4a1f      	ldr	r2, [pc, #124]	; (8000b90 <I2C_GPIO_SetPins+0x88>)
 8000b14:	4293      	cmp	r3, r2
 8000b16:	d118      	bne.n	8000b4a <I2C_GPIO_SetPins+0x42>
	{
		//PB6 SCL
		Pin_Config.GPIO_PinNumber = GPIO_PIN_6;
 8000b18:	2340      	movs	r3, #64	; 0x40
 8000b1a:	813b      	strh	r3, [r7, #8]
		Pin_Config.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000b1c:	2307      	movs	r3, #7
 8000b1e:	817b      	strh	r3, [r7, #10]
		Pin_Config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000b20:	2301      	movs	r3, #1
 8000b22:	81bb      	strh	r3, [r7, #12]
		GPIO_Init(GPIOB, &Pin_Config);
 8000b24:	f107 0308 	add.w	r3, r7, #8
 8000b28:	4619      	mov	r1, r3
 8000b2a:	481a      	ldr	r0, [pc, #104]	; (8000b94 <I2C_GPIO_SetPins+0x8c>)
 8000b2c:	f7ff fe10 	bl	8000750 <GPIO_Init>
		//PB7 SDA
		Pin_Config.GPIO_PinNumber = GPIO_PIN_7;
 8000b30:	2380      	movs	r3, #128	; 0x80
 8000b32:	813b      	strh	r3, [r7, #8]
		Pin_Config.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000b34:	2307      	movs	r3, #7
 8000b36:	817b      	strh	r3, [r7, #10]
		Pin_Config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000b38:	2301      	movs	r3, #1
 8000b3a:	81bb      	strh	r3, [r7, #12]
		GPIO_Init(GPIOB, &Pin_Config);
 8000b3c:	f107 0308 	add.w	r3, r7, #8
 8000b40:	4619      	mov	r1, r3
 8000b42:	4814      	ldr	r0, [pc, #80]	; (8000b94 <I2C_GPIO_SetPins+0x8c>)
 8000b44:	f7ff fe04 	bl	8000750 <GPIO_Init>
		Pin_Config.GPIO_PinNumber = GPIO_PIN_11;
		Pin_Config.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
		Pin_Config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
		GPIO_Init(GPIOB, &Pin_Config);
	}
}
 8000b48:	e01d      	b.n	8000b86 <I2C_GPIO_SetPins+0x7e>
	else if(I2Cx == I2C2)
 8000b4a:	687b      	ldr	r3, [r7, #4]
 8000b4c:	4a12      	ldr	r2, [pc, #72]	; (8000b98 <I2C_GPIO_SetPins+0x90>)
 8000b4e:	4293      	cmp	r3, r2
 8000b50:	d119      	bne.n	8000b86 <I2C_GPIO_SetPins+0x7e>
		Pin_Config.GPIO_PinNumber = GPIO_PIN_10;
 8000b52:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000b56:	813b      	strh	r3, [r7, #8]
		Pin_Config.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000b58:	2307      	movs	r3, #7
 8000b5a:	817b      	strh	r3, [r7, #10]
		Pin_Config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000b5c:	2301      	movs	r3, #1
 8000b5e:	81bb      	strh	r3, [r7, #12]
		GPIO_Init(GPIOB, &Pin_Config);
 8000b60:	f107 0308 	add.w	r3, r7, #8
 8000b64:	4619      	mov	r1, r3
 8000b66:	480b      	ldr	r0, [pc, #44]	; (8000b94 <I2C_GPIO_SetPins+0x8c>)
 8000b68:	f7ff fdf2 	bl	8000750 <GPIO_Init>
		Pin_Config.GPIO_PinNumber = GPIO_PIN_11;
 8000b6c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8000b70:	813b      	strh	r3, [r7, #8]
		Pin_Config.GPIO_PinMode = GPIO_MODE_OUTPUT_AF_OD;
 8000b72:	2307      	movs	r3, #7
 8000b74:	817b      	strh	r3, [r7, #10]
		Pin_Config.GPIO_PinSpeed = GPIO_SPEED_10MHz;
 8000b76:	2301      	movs	r3, #1
 8000b78:	81bb      	strh	r3, [r7, #12]
		GPIO_Init(GPIOB, &Pin_Config);
 8000b7a:	f107 0308 	add.w	r3, r7, #8
 8000b7e:	4619      	mov	r1, r3
 8000b80:	4804      	ldr	r0, [pc, #16]	; (8000b94 <I2C_GPIO_SetPins+0x8c>)
 8000b82:	f7ff fde5 	bl	8000750 <GPIO_Init>
}
 8000b86:	bf00      	nop
 8000b88:	3710      	adds	r7, #16
 8000b8a:	46bd      	mov	sp, r7
 8000b8c:	bd80      	pop	{r7, pc}
 8000b8e:	bf00      	nop
 8000b90:	40005400 	.word	0x40005400
 8000b94:	40010c00 	.word	0x40010c00
 8000b98:	40005800 	.word	0x40005800

08000b9c <I2C_MASTER_SendData>:
 * @param [in] 		- Start : select send start or repeated start
 * @retval 			- None
 * Note 			- None
 */
void I2C_MASTER_SendData(I2C_t *I2Cx, uint16_t Device_Address, uint8_t *Data, uint8_t Data_Length, STOP_Condition Stop, START_Condition Start)
{
 8000b9c:	b580      	push	{r7, lr}
 8000b9e:	b086      	sub	sp, #24
 8000ba0:	af00      	add	r7, sp, #0
 8000ba2:	60f8      	str	r0, [r7, #12]
 8000ba4:	607a      	str	r2, [r7, #4]
 8000ba6:	461a      	mov	r2, r3
 8000ba8:	460b      	mov	r3, r1
 8000baa:	817b      	strh	r3, [r7, #10]
 8000bac:	4613      	mov	r3, r2
 8000bae:	727b      	strb	r3, [r7, #9]
	int i = 0;
 8000bb0:	2300      	movs	r3, #0
 8000bb2:	617b      	str	r3, [r7, #20]

	// generate a start condition
	I2C_Start(I2Cx, Start, Enable);
 8000bb4:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8000bb8:	2201      	movs	r2, #1
 8000bba:	4619      	mov	r1, r3
 8000bbc:	68f8      	ldr	r0, [r7, #12]
 8000bbe:	f000 f941 	bl	8000e44 <I2C_Start>

	// Wait for EV5
	while(!(I2C_Get_FlagStatus(I2Cx, EV5)));
 8000bc2:	bf00      	nop
 8000bc4:	2101      	movs	r1, #1
 8000bc6:	68f8      	ldr	r0, [r7, #12]
 8000bc8:	f000 f8ba 	bl	8000d40 <I2C_Get_FlagStatus>
 8000bcc:	4603      	mov	r3, r0
 8000bce:	2b00      	cmp	r3, #0
 8000bd0:	d0f8      	beq.n	8000bc4 <I2C_MASTER_SendData+0x28>

	/* 3. Writing DR register with Address, Send Address */
	I2C_Send_Address(I2Cx, Device_Address, Transmitter);
 8000bd2:	897b      	ldrh	r3, [r7, #10]
 8000bd4:	2200      	movs	r2, #0
 8000bd6:	4619      	mov	r1, r3
 8000bd8:	68f8      	ldr	r0, [r7, #12]
 8000bda:	f000 f95a 	bl	8000e92 <I2C_Send_Address>

	// Wait for EV6
	while(!(I2C_Get_FlagStatus(I2Cx, EV6)));
 8000bde:	bf00      	nop
 8000be0:	2102      	movs	r1, #2
 8000be2:	68f8      	ldr	r0, [r7, #12]
 8000be4:	f000 f8ac 	bl	8000d40 <I2C_Get_FlagStatus>
 8000be8:	4603      	mov	r3, r0
 8000bea:	2b00      	cmp	r3, #0
 8000bec:	d0f8      	beq.n	8000be0 <I2C_MASTER_SendData+0x44>

	// Wait for EV8_1
	while(!(I2C_Get_FlagStatus(I2Cx, Master_Transmitter_Event)));
 8000bee:	bf00      	nop
 8000bf0:	4915      	ldr	r1, [pc, #84]	; (8000c48 <I2C_MASTER_SendData+0xac>)
 8000bf2:	68f8      	ldr	r0, [r7, #12]
 8000bf4:	f000 f8a4 	bl	8000d40 <I2C_Get_FlagStatus>
 8000bf8:	4603      	mov	r3, r0
 8000bfa:	2b00      	cmp	r3, #0
 8000bfc:	d0f8      	beq.n	8000bf0 <I2C_MASTER_SendData+0x54>

	/* Loop inside the data ready to send it */
	for (i = 0; i < Data_Length; ++i)
 8000bfe:	2300      	movs	r3, #0
 8000c00:	617b      	str	r3, [r7, #20]
 8000c02:	e011      	b.n	8000c28 <I2C_MASTER_SendData+0x8c>
	{
		// Write in the DR register the data to be sent
		I2Cx->DR = Data[i];
 8000c04:	697b      	ldr	r3, [r7, #20]
 8000c06:	687a      	ldr	r2, [r7, #4]
 8000c08:	4413      	add	r3, r2
 8000c0a:	781b      	ldrb	r3, [r3, #0]
 8000c0c:	461a      	mov	r2, r3
 8000c0e:	68fb      	ldr	r3, [r7, #12]
 8000c10:	611a      	str	r2, [r3, #16]

		// Wait for EV8
		while(!(I2C_Get_FlagStatus(I2Cx, EV8)));
 8000c12:	bf00      	nop
 8000c14:	2103      	movs	r1, #3
 8000c16:	68f8      	ldr	r0, [r7, #12]
 8000c18:	f000 f892 	bl	8000d40 <I2C_Get_FlagStatus>
 8000c1c:	4603      	mov	r3, r0
 8000c1e:	2b00      	cmp	r3, #0
 8000c20:	d0f8      	beq.n	8000c14 <I2C_MASTER_SendData+0x78>
	for (i = 0; i < Data_Length; ++i)
 8000c22:	697b      	ldr	r3, [r7, #20]
 8000c24:	3301      	adds	r3, #1
 8000c26:	617b      	str	r3, [r7, #20]
 8000c28:	7a7b      	ldrb	r3, [r7, #9]
 8000c2a:	697a      	ldr	r2, [r7, #20]
 8000c2c:	429a      	cmp	r2, r3
 8000c2e:	dbe9      	blt.n	8000c04 <I2C_MASTER_SendData+0x68>
	}

	// Send Stop Condition
	if(Stop == With_STOP)
 8000c30:	f897 3020 	ldrb.w	r3, [r7, #32]
 8000c34:	2b00      	cmp	r3, #0
 8000c36:	d103      	bne.n	8000c40 <I2C_MASTER_SendData+0xa4>
	{
		I2C_Stop(I2Cx, Enable);
 8000c38:	2101      	movs	r1, #1
 8000c3a:	68f8      	ldr	r0, [r7, #12]
 8000c3c:	f000 f949 	bl	8000ed2 <I2C_Stop>
	}
}
 8000c40:	bf00      	nop
 8000c42:	3718      	adds	r7, #24
 8000c44:	46bd      	mov	sp, r7
 8000c46:	bd80      	pop	{r7, pc}
 8000c48:	00070080 	.word	0x00070080

08000c4c <I2C_MASTER_ReceiveData>:
 * @param [in] 		- Start : select send start or repeated start
 * @retval 			- None
 * Note 			- None
 */
void I2C_MASTER_ReceiveData(I2C_t *I2Cx, uint16_t Device_Address, uint8_t *Data, uint8_t Data_Length, STOP_Condition Stop, START_Condition Start)
{
 8000c4c:	b580      	push	{r7, lr}
 8000c4e:	b086      	sub	sp, #24
 8000c50:	af00      	add	r7, sp, #0
 8000c52:	60f8      	str	r0, [r7, #12]
 8000c54:	607a      	str	r2, [r7, #4]
 8000c56:	461a      	mov	r2, r3
 8000c58:	460b      	mov	r3, r1
 8000c5a:	817b      	strh	r3, [r7, #10]
 8000c5c:	4613      	mov	r3, r2
 8000c5e:	727b      	strb	r3, [r7, #9]
	int i = 0;
 8000c60:	2300      	movs	r3, #0
 8000c62:	617b      	str	r3, [r7, #20]

	uint8_t index = I2Cx == I2C1 ? 0 : 1;
 8000c64:	68fb      	ldr	r3, [r7, #12]
 8000c66:	4a34      	ldr	r2, [pc, #208]	; (8000d38 <I2C_MASTER_ReceiveData+0xec>)
 8000c68:	4293      	cmp	r3, r2
 8000c6a:	bf14      	ite	ne
 8000c6c:	2301      	movne	r3, #1
 8000c6e:	2300      	moveq	r3, #0
 8000c70:	b2db      	uxtb	r3, r3
 8000c72:	74fb      	strb	r3, [r7, #19]

	// Set the start bit in the I2C_CR1 register to generate a start condition from this will start as master */
	I2C_Start(I2Cx, Start, Enable);
 8000c74:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8000c78:	2201      	movs	r2, #1
 8000c7a:	4619      	mov	r1, r3
 8000c7c:	68f8      	ldr	r0, [r7, #12]
 8000c7e:	f000 f8e1 	bl	8000e44 <I2C_Start>

	// Wait for EV5
	while(!(I2C_Get_FlagStatus(I2Cx, EV5)));
 8000c82:	bf00      	nop
 8000c84:	2101      	movs	r1, #1
 8000c86:	68f8      	ldr	r0, [r7, #12]
 8000c88:	f000 f85a 	bl	8000d40 <I2C_Get_FlagStatus>
 8000c8c:	4603      	mov	r3, r0
 8000c8e:	2b00      	cmp	r3, #0
 8000c90:	d0f8      	beq.n	8000c84 <I2C_MASTER_ReceiveData+0x38>

	// Writing DR register with Address, Send Address
	I2C_Send_Address(I2Cx, Device_Address, Receiver);
 8000c92:	897b      	ldrh	r3, [r7, #10]
 8000c94:	2201      	movs	r2, #1
 8000c96:	4619      	mov	r1, r3
 8000c98:	68f8      	ldr	r0, [r7, #12]
 8000c9a:	f000 f8fa 	bl	8000e92 <I2C_Send_Address>

	// Wait for EV6
	while(!(I2C_Get_FlagStatus(I2Cx, EV6)));
 8000c9e:	bf00      	nop
 8000ca0:	2102      	movs	r1, #2
 8000ca2:	68f8      	ldr	r0, [r7, #12]
 8000ca4:	f000 f84c 	bl	8000d40 <I2C_Get_FlagStatus>
 8000ca8:	4603      	mov	r3, r0
 8000caa:	2b00      	cmp	r3, #0
 8000cac:	d0f8      	beq.n	8000ca0 <I2C_MASTER_ReceiveData+0x54>

	// Enable Automatic ACK
	I2C_ACK(I2Cx, Enable);
 8000cae:	2101      	movs	r1, #1
 8000cb0:	68f8      	ldr	r0, [r7, #12]
 8000cb2:	f000 f929 	bl	8000f08 <I2C_ACK>

	if(Data_Length)
 8000cb6:	7a7b      	ldrb	r3, [r7, #9]
 8000cb8:	2b00      	cmp	r3, #0
 8000cba:	d018      	beq.n	8000cee <I2C_MASTER_ReceiveData+0xa2>
	{
		//receive the data
		for (i = Data_Length; i > 1 ; i--)
 8000cbc:	7a7b      	ldrb	r3, [r7, #9]
 8000cbe:	617b      	str	r3, [r7, #20]
 8000cc0:	e012      	b.n	8000ce8 <I2C_MASTER_ReceiveData+0x9c>
		{
			// Wait for EV7
			while(!(I2C_Get_FlagStatus(I2Cx, EV7)));
 8000cc2:	bf00      	nop
 8000cc4:	2104      	movs	r1, #4
 8000cc6:	68f8      	ldr	r0, [r7, #12]
 8000cc8:	f000 f83a 	bl	8000d40 <I2C_Get_FlagStatus>
 8000ccc:	4603      	mov	r3, r0
 8000cce:	2b00      	cmp	r3, #0
 8000cd0:	d0f8      	beq.n	8000cc4 <I2C_MASTER_ReceiveData+0x78>

			// Read the data in the DR register
			*Data = I2Cx->DR;
 8000cd2:	68fb      	ldr	r3, [r7, #12]
 8000cd4:	691b      	ldr	r3, [r3, #16]
 8000cd6:	b2da      	uxtb	r2, r3
 8000cd8:	687b      	ldr	r3, [r7, #4]
 8000cda:	701a      	strb	r2, [r3, #0]

			/* 10. Go to next address */
			Data++;
 8000cdc:	687b      	ldr	r3, [r7, #4]
 8000cde:	3301      	adds	r3, #1
 8000ce0:	607b      	str	r3, [r7, #4]
		for (i = Data_Length; i > 1 ; i--)
 8000ce2:	697b      	ldr	r3, [r7, #20]
 8000ce4:	3b01      	subs	r3, #1
 8000ce6:	617b      	str	r3, [r7, #20]
 8000ce8:	697b      	ldr	r3, [r7, #20]
 8000cea:	2b01      	cmp	r3, #1
 8000cec:	dce9      	bgt.n	8000cc2 <I2C_MASTER_ReceiveData+0x76>
		}
	}

	/* Send ---- > NACK */
	I2C_ACK(I2Cx, Disable);
 8000cee:	2100      	movs	r1, #0
 8000cf0:	68f8      	ldr	r0, [r7, #12]
 8000cf2:	f000 f909 	bl	8000f08 <I2C_ACK>

	// Send Stop Condition
	if(Stop == With_STOP)
 8000cf6:	f897 3020 	ldrb.w	r3, [r7, #32]
 8000cfa:	2b00      	cmp	r3, #0
 8000cfc:	d103      	bne.n	8000d06 <I2C_MASTER_ReceiveData+0xba>
	{
		I2C_Stop(I2Cx, Enable);
 8000cfe:	2101      	movs	r1, #1
 8000d00:	68f8      	ldr	r0, [r7, #12]
 8000d02:	f000 f8e6 	bl	8000ed2 <I2C_Stop>
	}

	// Re-Enable the automatic ACK
	if(Global_I2C_Config[index].ACK_Control == I2C_ACK_CONTROL_ENABLE)
 8000d06:	7cfa      	ldrb	r2, [r7, #19]
 8000d08:	490c      	ldr	r1, [pc, #48]	; (8000d3c <I2C_MASTER_ReceiveData+0xf0>)
 8000d0a:	4613      	mov	r3, r2
 8000d0c:	009b      	lsls	r3, r3, #2
 8000d0e:	4413      	add	r3, r2
 8000d10:	00db      	lsls	r3, r3, #3
 8000d12:	440b      	add	r3, r1
 8000d14:	3314      	adds	r3, #20
 8000d16:	681b      	ldr	r3, [r3, #0]
 8000d18:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000d1c:	d104      	bne.n	8000d28 <I2C_MASTER_ReceiveData+0xdc>
		I2C_ACK(I2Cx, Enable);
 8000d1e:	2101      	movs	r1, #1
 8000d20:	68f8      	ldr	r0, [r7, #12]
 8000d22:	f000 f8f1 	bl	8000f08 <I2C_ACK>
	else
		I2C_ACK(I2Cx, Disable);
}
 8000d26:	e003      	b.n	8000d30 <I2C_MASTER_ReceiveData+0xe4>
		I2C_ACK(I2Cx, Disable);
 8000d28:	2100      	movs	r1, #0
 8000d2a:	68f8      	ldr	r0, [r7, #12]
 8000d2c:	f000 f8ec 	bl	8000f08 <I2C_ACK>
}
 8000d30:	bf00      	nop
 8000d32:	3718      	adds	r7, #24
 8000d34:	46bd      	mov	sp, r7
 8000d36:	bd80      	pop	{r7, pc}
 8000d38:	40005400 	.word	0x40005400
 8000d3c:	20000058 	.word	0x20000058

08000d40 <I2C_Get_FlagStatus>:
/* ======================== Generic APIs ========================== */
/* ================================================================ */


static I2C_Flagstatus I2C_Get_FlagStatus(I2C_t *I2Cx, Status Flag)
{
 8000d40:	b480      	push	{r7}
 8000d42:	b087      	sub	sp, #28
 8000d44:	af00      	add	r7, sp, #0
 8000d46:	6078      	str	r0, [r7, #4]
 8000d48:	6039      	str	r1, [r7, #0]
	//vuint32_t Dummy_Read = 0; // Volatile for compiler optimization
	uint32_t flag1 = 0, flag2 = 0, Last_Event;
 8000d4a:	2300      	movs	r3, #0
 8000d4c:	613b      	str	r3, [r7, #16]
 8000d4e:	2300      	movs	r3, #0
 8000d50:	60fb      	str	r3, [r7, #12]
	I2C_Flagstatus Bit_Status = RESET;
 8000d52:	2300      	movs	r3, #0
 8000d54:	75fb      	strb	r3, [r7, #23]

	switch (Flag)
 8000d56:	683b      	ldr	r3, [r7, #0]
 8000d58:	2b04      	cmp	r3, #4
 8000d5a:	d80f      	bhi.n	8000d7c <I2C_Get_FlagStatus+0x3c>
 8000d5c:	683b      	ldr	r3, [r7, #0]
 8000d5e:	2b04      	cmp	r3, #4
 8000d60:	d867      	bhi.n	8000e32 <I2C_Get_FlagStatus+0xf2>
 8000d62:	a201      	add	r2, pc, #4	; (adr r2, 8000d68 <I2C_Get_FlagStatus+0x28>)
 8000d64:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000d68:	08000d87 	.word	0x08000d87
 8000d6c:	08000d9f 	.word	0x08000d9f
 8000d70:	08000db7 	.word	0x08000db7
 8000d74:	08000dcf 	.word	0x08000dcf
 8000d78:	08000de7 	.word	0x08000de7
 8000d7c:	683b      	ldr	r3, [r7, #0]
 8000d7e:	4a30      	ldr	r2, [pc, #192]	; (8000e40 <I2C_Get_FlagStatus+0x100>)
 8000d80:	4293      	cmp	r3, r2
 8000d82:	d03c      	beq.n	8000dfe <I2C_Get_FlagStatus+0xbe>
 8000d84:	e055      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
				1: Communication ongoing on the bus
				 Set by hardware on detection of SDA or SCL low
				 cleared by hardware on detection of a Stop condition.
				It indicates a communication in progress on the bus. This information is still updated when the interface is disabled (PE=0).
		 */
		if((I2Cx->SR2) & (I2C_SR2_BUSY))
 8000d86:	687b      	ldr	r3, [r7, #4]
 8000d88:	699b      	ldr	r3, [r3, #24]
 8000d8a:	f003 0302 	and.w	r3, r3, #2
 8000d8e:	2b00      	cmp	r3, #0
 8000d90:	d002      	beq.n	8000d98 <I2C_Get_FlagStatus+0x58>
			Bit_Status = SET;
 8000d92:	2301      	movs	r3, #1
 8000d94:	75fb      	strb	r3, [r7, #23]
		else
			Bit_Status = RESET;
		break;
 8000d96:	e04c      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			Bit_Status = RESET;
 8000d98:	2300      	movs	r3, #0
 8000d9a:	75fb      	strb	r3, [r7, #23]
		break;
 8000d9c:	e049      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			0: No Start condition
			1: Start condition generated.
			   Set when a Start condition generated.
			   Cleared by software by reading the SR1 register followed by writing the DR register, or by hardware when PE=0
		 */
		if((I2Cx->SR1) & (I2C_SR1_SB))
 8000d9e:	687b      	ldr	r3, [r7, #4]
 8000da0:	695b      	ldr	r3, [r3, #20]
 8000da2:	f003 0301 	and.w	r3, r3, #1
 8000da6:	2b00      	cmp	r3, #0
 8000da8:	d002      	beq.n	8000db0 <I2C_Get_FlagStatus+0x70>
			Bit_Status = SET;
 8000daa:	2301      	movs	r3, #1
 8000dac:	75fb      	strb	r3, [r7, #23]
		else
			Bit_Status = RESET;
		break;
 8000dae:	e040      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			Bit_Status = RESET;
 8000db0:	2300      	movs	r3, #0
 8000db2:	75fb      	strb	r3, [r7, #23]
		break;
 8000db4:	e03d      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			 For 10-bit addressing, the bit is set after the ACK of the 2nd byte.
			 For 7-bit addressing, the bit is set after the ACK of the byte.

			Note: ADDR is not set after a NACK reception
		 */
		if((I2Cx->SR1) & (I2C_SR1_ADDR))
 8000db6:	687b      	ldr	r3, [r7, #4]
 8000db8:	695b      	ldr	r3, [r3, #20]
 8000dba:	f003 0302 	and.w	r3, r3, #2
 8000dbe:	2b00      	cmp	r3, #0
 8000dc0:	d002      	beq.n	8000dc8 <I2C_Get_FlagStatus+0x88>
			Bit_Status = SET;
 8000dc2:	2301      	movs	r3, #1
 8000dc4:	75fb      	strb	r3, [r7, #23]
		else
			Bit_Status = RESET;

		/* This bit is cleared by software reading SR1 register followed reading SR2, or by hardware when PE=0. */
		//Dummy_Read = I2Cx->SR2;
		break;
 8000dc6:	e034      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			Bit_Status = RESET;
 8000dc8:	2300      	movs	r3, #0
 8000dca:	75fb      	strb	r3, [r7, #23]
		break;
 8000dcc:	e031      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
				 Cleared by software writing to the DR register or by hardware after a start or a stop condition or when PE=0.
				TxE is not set if either a NACK is received, or if next byte to be transmitted is PEC (PEC=1)
				Note: TxE is not cleared by writing the first data being transmitted, or by writing data when
				BTF is set, as in both cases the data register is still empty.
		 */
		if((I2Cx->SR1) & (I2C_SR1_TXE))
 8000dce:	687b      	ldr	r3, [r7, #4]
 8000dd0:	695b      	ldr	r3, [r3, #20]
 8000dd2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000dd6:	2b00      	cmp	r3, #0
 8000dd8:	d002      	beq.n	8000de0 <I2C_Get_FlagStatus+0xa0>
			Bit_Status = SET;
 8000dda:	2301      	movs	r3, #1
 8000ddc:	75fb      	strb	r3, [r7, #23]
		else
			Bit_Status = RESET;
		break;
 8000dde:	e028      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			Bit_Status = RESET;
 8000de0:	2300      	movs	r3, #0
 8000de2:	75fb      	strb	r3, [r7, #23]
		break;
 8000de4:	e025      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
				 Set when data register is not empty in receiver mode. RxNE is not set during address phase.
				 Cleared by software reading or writing the DR register or by hardware when PE=0.
				RxNE is not set in case of ARLO event.
				Note: RxNE is not cleared by reading data when BTF is set, as the data register is still full.
		 */
		if((I2Cx->SR1) & (I2C_SR1_RXNE))
 8000de6:	687b      	ldr	r3, [r7, #4]
 8000de8:	695b      	ldr	r3, [r3, #20]
 8000dea:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000dee:	2b00      	cmp	r3, #0
 8000df0:	d002      	beq.n	8000df8 <I2C_Get_FlagStatus+0xb8>
			Bit_Status = SET;
 8000df2:	2301      	movs	r3, #1
 8000df4:	75fb      	strb	r3, [r7, #23]
		else
			Bit_Status = RESET;
		break;
 8000df6:	e01c      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>
			Bit_Status = RESET;
 8000df8:	2300      	movs	r3, #0
 8000dfa:	75fb      	strb	r3, [r7, #23]
		break;
 8000dfc:	e019      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>

	case Master_Transmitter_Event :
	{
		/* Check if BUSY ,TRA ,MSL W,TXE flags are all set */

		flag1 = I2Cx->SR1;
 8000dfe:	687b      	ldr	r3, [r7, #4]
 8000e00:	695b      	ldr	r3, [r3, #20]
 8000e02:	613b      	str	r3, [r7, #16]
		flag2 = I2Cx->SR2;
 8000e04:	687b      	ldr	r3, [r7, #4]
 8000e06:	699b      	ldr	r3, [r3, #24]
 8000e08:	60fb      	str	r3, [r7, #12]
		flag2 = flag2 << 16;
 8000e0a:	68fb      	ldr	r3, [r7, #12]
 8000e0c:	041b      	lsls	r3, r3, #16
 8000e0e:	60fb      	str	r3, [r7, #12]
		/* Get the last event value from I2C status register */
		Last_Event = (flag1 | flag2) & ((uint32_t)0x00FFFFFF);
 8000e10:	693a      	ldr	r2, [r7, #16]
 8000e12:	68fb      	ldr	r3, [r7, #12]
 8000e14:	4313      	orrs	r3, r2
 8000e16:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000e1a:	60bb      	str	r3, [r7, #8]
		/* Check whether the last event contains the I2C_EVENT */
		if ((Last_Event & Flag) == Flag)
 8000e1c:	68ba      	ldr	r2, [r7, #8]
 8000e1e:	683b      	ldr	r3, [r7, #0]
 8000e20:	4013      	ands	r3, r2
 8000e22:	683a      	ldr	r2, [r7, #0]
 8000e24:	429a      	cmp	r2, r3
 8000e26:	d102      	bne.n	8000e2e <I2C_Get_FlagStatus+0xee>
			Bit_Status = SET ;
 8000e28:	2301      	movs	r3, #1
 8000e2a:	75fb      	strb	r3, [r7, #23]
 8000e2c:	e001      	b.n	8000e32 <I2C_Get_FlagStatus+0xf2>

		else
			Bit_Status = RESET ;
 8000e2e:	2300      	movs	r3, #0
 8000e30:	75fb      	strb	r3, [r7, #23]
	}
	}
	return Bit_Status;
 8000e32:	7dfb      	ldrb	r3, [r7, #23]
}
 8000e34:	4618      	mov	r0, r3
 8000e36:	371c      	adds	r7, #28
 8000e38:	46bd      	mov	sp, r7
 8000e3a:	bc80      	pop	{r7}
 8000e3c:	4770      	bx	lr
 8000e3e:	bf00      	nop
 8000e40:	00070080 	.word	0x00070080

08000e44 <I2C_Start>:

static void I2C_Start(I2C_t *I2Cx,START_Condition Start, Functional_State State)
{
 8000e44:	b580      	push	{r7, lr}
 8000e46:	b082      	sub	sp, #8
 8000e48:	af00      	add	r7, sp, #0
 8000e4a:	6078      	str	r0, [r7, #4]
 8000e4c:	460b      	mov	r3, r1
 8000e4e:	70fb      	strb	r3, [r7, #3]
 8000e50:	4613      	mov	r3, r2
 8000e52:	70bb      	strb	r3, [r7, #2]
	// Check the type of start (Start or Repeated Start)
	if(Start != Repeated_START)
 8000e54:	78fb      	ldrb	r3, [r7, #3]
 8000e56:	2b01      	cmp	r3, #1
 8000e58:	d007      	beq.n	8000e6a <I2C_Start+0x26>
	{
		// Check if the bus is idle
		while(I2C_Get_FlagStatus(I2Cx, BUS_BUSY));
 8000e5a:	bf00      	nop
 8000e5c:	2100      	movs	r1, #0
 8000e5e:	6878      	ldr	r0, [r7, #4]
 8000e60:	f7ff ff6e 	bl	8000d40 <I2C_Get_FlagStatus>
 8000e64:	4603      	mov	r3, r0
 8000e66:	2b00      	cmp	r3, #0
 8000e68:	d1f8      	bne.n	8000e5c <I2C_Start+0x18>
		1: Repeated start generation
		In Slave mode:
		0: No Start generation
		1: Start generation when the bus is free
	 */
	if(State != Disable)
 8000e6a:	78bb      	ldrb	r3, [r7, #2]
 8000e6c:	2b00      	cmp	r3, #0
 8000e6e:	d006      	beq.n	8000e7e <I2C_Start+0x3a>
	{
		// Generate a START condition
		I2Cx->CR1 |= I2C_CR1_START;
 8000e70:	687b      	ldr	r3, [r7, #4]
 8000e72:	681b      	ldr	r3, [r3, #0]
 8000e74:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8000e78:	687b      	ldr	r3, [r7, #4]
 8000e7a:	601a      	str	r2, [r3, #0]
	{
		// Disable the START condition generation
		I2Cx->CR1 &= ~(I2C_CR1_START);
	}

}
 8000e7c:	e005      	b.n	8000e8a <I2C_Start+0x46>
		I2Cx->CR1 &= ~(I2C_CR1_START);
 8000e7e:	687b      	ldr	r3, [r7, #4]
 8000e80:	681b      	ldr	r3, [r3, #0]
 8000e82:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8000e86:	687b      	ldr	r3, [r7, #4]
 8000e88:	601a      	str	r2, [r3, #0]
}
 8000e8a:	bf00      	nop
 8000e8c:	3708      	adds	r7, #8
 8000e8e:	46bd      	mov	sp, r7
 8000e90:	bd80      	pop	{r7, pc}

08000e92 <I2C_Send_Address>:

static void I2C_Send_Address(I2C_t *I2Cx, uint16_t Device_Address,I2C_Direction Direction)
{
 8000e92:	b480      	push	{r7}
 8000e94:	b083      	sub	sp, #12
 8000e96:	af00      	add	r7, sp, #0
 8000e98:	6078      	str	r0, [r7, #4]
 8000e9a:	460b      	mov	r3, r1
 8000e9c:	807b      	strh	r3, [r7, #2]
 8000e9e:	4613      	mov	r3, r2
 8000ea0:	707b      	strb	r3, [r7, #1]
	// Support 7-bit address mode only
	if(Direction == Receiver)
 8000ea2:	787b      	ldrb	r3, [r7, #1]
 8000ea4:	2b01      	cmp	r3, #1
 8000ea6:	d107      	bne.n	8000eb8 <I2C_Send_Address+0x26>
	{
		// Set the address bit 0 for read
		I2Cx->DR = ((Device_Address << 1) | (0x01));
 8000ea8:	887b      	ldrh	r3, [r7, #2]
 8000eaa:	005b      	lsls	r3, r3, #1
 8000eac:	f043 0301 	orr.w	r3, r3, #1
 8000eb0:	461a      	mov	r2, r3
 8000eb2:	687b      	ldr	r3, [r7, #4]
 8000eb4:	611a      	str	r2, [r3, #16]
	else if(Direction == Transmitter)
	{
		// Reset the address bit 0 for write
		I2Cx->DR = (Device_Address << 1);
	}
}
 8000eb6:	e007      	b.n	8000ec8 <I2C_Send_Address+0x36>
	else if(Direction == Transmitter)
 8000eb8:	787b      	ldrb	r3, [r7, #1]
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	d104      	bne.n	8000ec8 <I2C_Send_Address+0x36>
		I2Cx->DR = (Device_Address << 1);
 8000ebe:	887b      	ldrh	r3, [r7, #2]
 8000ec0:	005b      	lsls	r3, r3, #1
 8000ec2:	461a      	mov	r2, r3
 8000ec4:	687b      	ldr	r3, [r7, #4]
 8000ec6:	611a      	str	r2, [r3, #16]
}
 8000ec8:	bf00      	nop
 8000eca:	370c      	adds	r7, #12
 8000ecc:	46bd      	mov	sp, r7
 8000ece:	bc80      	pop	{r7}
 8000ed0:	4770      	bx	lr

08000ed2 <I2C_Stop>:

static void I2C_Stop(I2C_t *I2Cx, Functional_State State)
{
 8000ed2:	b480      	push	{r7}
 8000ed4:	b083      	sub	sp, #12
 8000ed6:	af00      	add	r7, sp, #0
 8000ed8:	6078      	str	r0, [r7, #4]
 8000eda:	460b      	mov	r3, r1
 8000edc:	70fb      	strb	r3, [r7, #3]
	if(State == Enable)
 8000ede:	78fb      	ldrb	r3, [r7, #3]
 8000ee0:	2b01      	cmp	r3, #1
 8000ee2:	d106      	bne.n	8000ef2 <I2C_Stop+0x20>
	{
		// Generate a stop condition, Enable stop bit
		I2Cx->CR1 |= (I2C_CR1_STOP);
 8000ee4:	687b      	ldr	r3, [r7, #4]
 8000ee6:	681b      	ldr	r3, [r3, #0]
 8000ee8:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8000eec:	687b      	ldr	r3, [r7, #4]
 8000eee:	601a      	str	r2, [r3, #0]
	else
	{
		// Disable the stop condition generation, Disable stop bit
		I2Cx->CR1 &= ~(I2C_CR1_STOP);
	}
}
 8000ef0:	e005      	b.n	8000efe <I2C_Stop+0x2c>
		I2Cx->CR1 &= ~(I2C_CR1_STOP);
 8000ef2:	687b      	ldr	r3, [r7, #4]
 8000ef4:	681b      	ldr	r3, [r3, #0]
 8000ef6:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8000efa:	687b      	ldr	r3, [r7, #4]
 8000efc:	601a      	str	r2, [r3, #0]
}
 8000efe:	bf00      	nop
 8000f00:	370c      	adds	r7, #12
 8000f02:	46bd      	mov	sp, r7
 8000f04:	bc80      	pop	{r7}
 8000f06:	4770      	bx	lr

08000f08 <I2C_ACK>:

static void I2C_ACK(I2C_t *I2Cx, Functional_State State)
{
 8000f08:	b480      	push	{r7}
 8000f0a:	b083      	sub	sp, #12
 8000f0c:	af00      	add	r7, sp, #0
 8000f0e:	6078      	str	r0, [r7, #4]
 8000f10:	460b      	mov	r3, r1
 8000f12:	70fb      	strb	r3, [r7, #3]
	if(State == Enable)
 8000f14:	78fb      	ldrb	r3, [r7, #3]
 8000f16:	2b01      	cmp	r3, #1
 8000f18:	d106      	bne.n	8000f28 <I2C_ACK+0x20>
	{
		// Enable Automatic ACK
		I2Cx->CR1 |= (I2C_CR1_ACK);
 8000f1a:	687b      	ldr	r3, [r7, #4]
 8000f1c:	681b      	ldr	r3, [r3, #0]
 8000f1e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8000f22:	687b      	ldr	r3, [r7, #4]
 8000f24:	601a      	str	r2, [r3, #0]
	else
	{
		// Disable Automatic ACK
		I2Cx->CR1 &= ~(I2C_CR1_ACK);
	}
}
 8000f26:	e005      	b.n	8000f34 <I2C_ACK+0x2c>
		I2Cx->CR1 &= ~(I2C_CR1_ACK);
 8000f28:	687b      	ldr	r3, [r7, #4]
 8000f2a:	681b      	ldr	r3, [r3, #0]
 8000f2c:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8000f30:	687b      	ldr	r3, [r7, #4]
 8000f32:	601a      	str	r2, [r3, #0]
}
 8000f34:	bf00      	nop
 8000f36:	370c      	adds	r7, #12
 8000f38:	46bd      	mov	sp, r7
 8000f3a:	bc80      	pop	{r7}
 8000f3c:	4770      	bx	lr
	...

08000f40 <I2C1_EV_IRQHandler>:


void I2C1_EV_IRQHandler(void)
{
 8000f40:	b580      	push	{r7, lr}
 8000f42:	b086      	sub	sp, #24
 8000f44:	af00      	add	r7, sp, #0
	volatile uint32_t dummy_read = 0 ;
 8000f46:	2300      	movs	r3, #0
 8000f48:	607b      	str	r3, [r7, #4]
	I2C_t* I2Cx = I2C1 ;
 8000f4a:	4b37      	ldr	r3, [pc, #220]	; (8001028 <I2C1_EV_IRQHandler+0xe8>)
 8000f4c:	617b      	str	r3, [r7, #20]
	//Interrupt handling for both master and slave mode of a device
	uint32_t temp1, temp2, temp3;

	temp1   = I2Cx->CR2 & (  I2C_CR2_ITEVTEN) ;
 8000f4e:	697b      	ldr	r3, [r7, #20]
 8000f50:	685b      	ldr	r3, [r3, #4]
 8000f52:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000f56:	613b      	str	r3, [r7, #16]
	temp2   = I2Cx->CR2 & ( I2C_CR2_ITBUFEN) ;
 8000f58:	697b      	ldr	r3, [r7, #20]
 8000f5a:	685b      	ldr	r3, [r3, #4]
 8000f5c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000f60:	60fb      	str	r3, [r7, #12]
	temp3  = I2Cx->SR1 & ( I2C_SR1_STOPF);
 8000f62:	697b      	ldr	r3, [r7, #20]
 8000f64:	695b      	ldr	r3, [r3, #20]
 8000f66:	f003 0310 	and.w	r3, r3, #16
 8000f6a:	60bb      	str	r3, [r7, #8]


	// Handle For interrupt generated by STOPF event
	// Note : Stop detection flag is applicable only slave mode
	if(temp1 && temp3)
 8000f6c:	693b      	ldr	r3, [r7, #16]
 8000f6e:	2b00      	cmp	r3, #0
 8000f70:	d00a      	beq.n	8000f88 <I2C1_EV_IRQHandler+0x48>
 8000f72:	68bb      	ldr	r3, [r7, #8]
 8000f74:	2b00      	cmp	r3, #0
 8000f76:	d007      	beq.n	8000f88 <I2C1_EV_IRQHandler+0x48>
	{
		//STOF flag is set
		//Clear the STOPF ( i.e 1) read SR1 2) Write to CR1 )
		I2Cx->CR1 |= 0x0000;
 8000f78:	697b      	ldr	r3, [r7, #20]
 8000f7a:	681a      	ldr	r2, [r3, #0]
 8000f7c:	697b      	ldr	r3, [r7, #20]
 8000f7e:	601a      	str	r2, [r3, #0]
		Slave_States(I2Cx,I2C_EV_STOP);
 8000f80:	2100      	movs	r1, #0
 8000f82:	6978      	ldr	r0, [r7, #20]
 8000f84:	f000 f852 	bl	800102c <Slave_States>


	}
	//----------------------------------------------------------
	temp3  = I2Cx->SR1 & (I2C_SR1_ADDR);
 8000f88:	697b      	ldr	r3, [r7, #20]
 8000f8a:	695b      	ldr	r3, [r3, #20]
 8000f8c:	f003 0302 	and.w	r3, r3, #2
 8000f90:	60bb      	str	r3, [r7, #8]
	// Handle For interrupt generated by ADDR event
	//Note : When master mode : Address is sent
	//		 When Slave mode   : Address matched with own address
	if(temp1 && temp3)
 8000f92:	693b      	ldr	r3, [r7, #16]
 8000f94:	2b00      	cmp	r3, #0
 8000f96:	d012      	beq.n	8000fbe <I2C1_EV_IRQHandler+0x7e>
 8000f98:	68bb      	ldr	r3, [r7, #8]
 8000f9a:	2b00      	cmp	r3, #0
 8000f9c:	d00f      	beq.n	8000fbe <I2C1_EV_IRQHandler+0x7e>
	{
		// interrupt is generated because of ADDR event
		//check for device mode
		if(I2Cx->SR2 & ( I2C_SR2_MSL))
 8000f9e:	697b      	ldr	r3, [r7, #20]
 8000fa0:	699b      	ldr	r3, [r3, #24]
 8000fa2:	f003 0301 	and.w	r3, r3, #1
 8000fa6:	2b00      	cmp	r3, #0
 8000fa8:	d109      	bne.n	8000fbe <I2C1_EV_IRQHandler+0x7e>

		}else
		{
			//slave mode
			//clear the ADDR flag ( read SR1 , read SR2)
			dummy_read = I2Cx->SR1;
 8000faa:	697b      	ldr	r3, [r7, #20]
 8000fac:	695b      	ldr	r3, [r3, #20]
 8000fae:	607b      	str	r3, [r7, #4]
			dummy_read = I2Cx->SR2;
 8000fb0:	697b      	ldr	r3, [r7, #20]
 8000fb2:	699b      	ldr	r3, [r3, #24]
 8000fb4:	607b      	str	r3, [r7, #4]
			Slave_States(I2Cx,I2C_EV_ADD_MATCHED);
 8000fb6:	2101      	movs	r1, #1
 8000fb8:	6978      	ldr	r0, [r7, #20]
 8000fba:	f000 f837 	bl	800102c <Slave_States>

		}
	}
	//----------------------------------------------------------

	temp3  = I2Cx->SR1 & ( I2C_SR1_TXE);
 8000fbe:	697b      	ldr	r3, [r7, #20]
 8000fc0:	695b      	ldr	r3, [r3, #20]
 8000fc2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000fc6:	60bb      	str	r3, [r7, #8]
	// Handle For interrupt generated by TXE event
	if(temp1 && temp2 && temp3)
 8000fc8:	693b      	ldr	r3, [r7, #16]
 8000fca:	2b00      	cmp	r3, #0
 8000fcc:	d00f      	beq.n	8000fee <I2C1_EV_IRQHandler+0xae>
 8000fce:	68fb      	ldr	r3, [r7, #12]
 8000fd0:	2b00      	cmp	r3, #0
 8000fd2:	d00c      	beq.n	8000fee <I2C1_EV_IRQHandler+0xae>
 8000fd4:	68bb      	ldr	r3, [r7, #8]
 8000fd6:	2b00      	cmp	r3, #0
 8000fd8:	d009      	beq.n	8000fee <I2C1_EV_IRQHandler+0xae>
	{
		//Check for device mode
		if(I2Cx->SR2 & (I2C_SR2_MSL))
 8000fda:	697b      	ldr	r3, [r7, #20]
 8000fdc:	699b      	ldr	r3, [r3, #24]
 8000fde:	f003 0301 	and.w	r3, r3, #1
 8000fe2:	2b00      	cmp	r3, #0
 8000fe4:	d103      	bne.n	8000fee <I2C1_EV_IRQHandler+0xae>
		{

		}else
		{
			//slave
			Slave_States(I2Cx,I2C_EV_DATA_REQ);
 8000fe6:	2102      	movs	r1, #2
 8000fe8:	6978      	ldr	r0, [r7, #20]
 8000fea:	f000 f81f 	bl	800102c <Slave_States>
		}
	}

	//----------------------------------------------------------

	temp3  = I2Cx->SR1 & ( I2C_SR1_RXNE);
 8000fee:	697b      	ldr	r3, [r7, #20]
 8000ff0:	695b      	ldr	r3, [r3, #20]
 8000ff2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000ff6:	60bb      	str	r3, [r7, #8]
	// Handle For interrupt generated by 	SB=1, cleared by reading SR1 register followed by writing DR register with Address.
	if(temp1 && temp2 && temp3)
 8000ff8:	693b      	ldr	r3, [r7, #16]
 8000ffa:	2b00      	cmp	r3, #0
 8000ffc:	d00f      	beq.n	800101e <I2C1_EV_IRQHandler+0xde>
 8000ffe:	68fb      	ldr	r3, [r7, #12]
 8001000:	2b00      	cmp	r3, #0
 8001002:	d00c      	beq.n	800101e <I2C1_EV_IRQHandler+0xde>
 8001004:	68bb      	ldr	r3, [r7, #8]
 8001006:	2b00      	cmp	r3, #0
 8001008:	d009      	beq.n	800101e <I2C1_EV_IRQHandler+0xde>
	{
		//check device mode .
		if(I2Cx->SR2 & ( I2C_SR2_MSL))
 800100a:	697b      	ldr	r3, [r7, #20]
 800100c:	699b      	ldr	r3, [r3, #24]
 800100e:	f003 0301 	and.w	r3, r3, #1
 8001012:	2b00      	cmp	r3, #0
 8001014:	d103      	bne.n	800101e <I2C1_EV_IRQHandler+0xde>
			//The device is master

		}else
		{
			//slave
			Slave_States(I2Cx,I2C_EV_DATA_RCV);
 8001016:	2103      	movs	r1, #3
 8001018:	6978      	ldr	r0, [r7, #20]
 800101a:	f000 f807 	bl	800102c <Slave_States>

		}
	}
}
 800101e:	bf00      	nop
 8001020:	3718      	adds	r7, #24
 8001022:	46bd      	mov	sp, r7
 8001024:	bd80      	pop	{r7, pc}
 8001026:	bf00      	nop
 8001028:	40005400 	.word	0x40005400

0800102c <Slave_States>:
static void Slave_States (I2C_t* I2Cx  ,Slave_State state)
{
 800102c:	b580      	push	{r7, lr}
 800102e:	b084      	sub	sp, #16
 8001030:	af00      	add	r7, sp, #0
 8001032:	6078      	str	r0, [r7, #4]
 8001034:	460b      	mov	r3, r1
 8001036:	70fb      	strb	r3, [r7, #3]
	uint8_t index =    I2Cx == I2C1 ? 0: 1 ;
 8001038:	687b      	ldr	r3, [r7, #4]
 800103a:	4a30      	ldr	r2, [pc, #192]	; (80010fc <Slave_States+0xd0>)
 800103c:	4293      	cmp	r3, r2
 800103e:	bf14      	ite	ne
 8001040:	2301      	movne	r3, #1
 8001042:	2300      	moveq	r3, #0
 8001044:	b2db      	uxtb	r3, r3
 8001046:	73fb      	strb	r3, [r7, #15]

	switch (state)
 8001048:	78fb      	ldrb	r3, [r7, #3]
 800104a:	2b03      	cmp	r3, #3
 800104c:	d851      	bhi.n	80010f2 <Slave_States+0xc6>
 800104e:	a201      	add	r2, pc, #4	; (adr r2, 8001054 <Slave_States+0x28>)
 8001050:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001054:	08001065 	.word	0x08001065
 8001058:	08001089 	.word	0x08001089
 800105c:	080010a1 	.word	0x080010a1
 8001060:	080010c5 	.word	0x080010c5
	{
	case I2C_EV_STOP:
	{
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & ( I2C_SR2_TRA))
 8001064:	687b      	ldr	r3, [r7, #4]
 8001066:	699b      	ldr	r3, [r3, #24]
 8001068:	f003 0304 	and.w	r3, r3, #4
 800106c:	2b00      	cmp	r3, #0
 800106e:	d03b      	beq.n	80010e8 <Slave_States+0xbc>
		{
			//Notify APP that the Stop Condition is sent by the master
			Global_I2C_Config [index].Slave_CallBack (I2C_EV_STOP) ;
 8001070:	7bfa      	ldrb	r2, [r7, #15]
 8001072:	4923      	ldr	r1, [pc, #140]	; (8001100 <Slave_States+0xd4>)
 8001074:	4613      	mov	r3, r2
 8001076:	009b      	lsls	r3, r3, #2
 8001078:	4413      	add	r3, r2
 800107a:	00db      	lsls	r3, r3, #3
 800107c:	440b      	add	r3, r1
 800107e:	3324      	adds	r3, #36	; 0x24
 8001080:	681b      	ldr	r3, [r3, #0]
 8001082:	2000      	movs	r0, #0
 8001084:	4798      	blx	r3
		}

		break ;
 8001086:	e02f      	b.n	80010e8 <Slave_States+0xbc>
	}

	case I2C_EV_ADD_MATCHED:
	{
		//Notify APP that the Stop Condition is sent by the master
		Global_I2C_Config [index].Slave_CallBack (I2C_EV_ADD_MATCHED) ;
 8001088:	7bfa      	ldrb	r2, [r7, #15]
 800108a:	491d      	ldr	r1, [pc, #116]	; (8001100 <Slave_States+0xd4>)
 800108c:	4613      	mov	r3, r2
 800108e:	009b      	lsls	r3, r3, #2
 8001090:	4413      	add	r3, r2
 8001092:	00db      	lsls	r3, r3, #3
 8001094:	440b      	add	r3, r1
 8001096:	3324      	adds	r3, #36	; 0x24
 8001098:	681b      	ldr	r3, [r3, #0]
 800109a:	2001      	movs	r0, #1
 800109c:	4798      	blx	r3

		break ;
 800109e:	e028      	b.n	80010f2 <Slave_States+0xc6>
	}

	case I2C_EV_DATA_REQ:
	{
		//make sure that the slave is really in transmitter mode
		if(I2Cx->SR2 & ( I2C_SR2_TRA))
 80010a0:	687b      	ldr	r3, [r7, #4]
 80010a2:	699b      	ldr	r3, [r3, #24]
 80010a4:	f003 0304 	and.w	r3, r3, #4
 80010a8:	2b00      	cmp	r3, #0
 80010aa:	d01f      	beq.n	80010ec <Slave_States+0xc0>
		{
			//the APP layer should send the data (MCAL_I2C_SlaveSendData ) in this state
			Global_I2C_Config [index].Slave_CallBack (I2C_EV_DATA_REQ) ;
 80010ac:	7bfa      	ldrb	r2, [r7, #15]
 80010ae:	4914      	ldr	r1, [pc, #80]	; (8001100 <Slave_States+0xd4>)
 80010b0:	4613      	mov	r3, r2
 80010b2:	009b      	lsls	r3, r3, #2
 80010b4:	4413      	add	r3, r2
 80010b6:	00db      	lsls	r3, r3, #3
 80010b8:	440b      	add	r3, r1
 80010ba:	3324      	adds	r3, #36	; 0x24
 80010bc:	681b      	ldr	r3, [r3, #0]
 80010be:	2002      	movs	r0, #2
 80010c0:	4798      	blx	r3
		}

		break ;
 80010c2:	e013      	b.n	80010ec <Slave_States+0xc0>
	}
	case I2C_EV_DATA_RCV:
	{
		//make sure that the slave is really in receiver mode
		if(!(I2Cx->SR2 & ( I2C_SR2_TRA)))
 80010c4:	687b      	ldr	r3, [r7, #4]
 80010c6:	699b      	ldr	r3, [r3, #24]
 80010c8:	f003 0304 	and.w	r3, r3, #4
 80010cc:	2b00      	cmp	r3, #0
 80010ce:	d10f      	bne.n	80010f0 <Slave_States+0xc4>
		{
			//the APP layer should read the data (MCAL_I2C_SlaveReceiveData ) in this state
			Global_I2C_Config [index].Slave_CallBack (I2C_EV_DATA_RCV) ;
 80010d0:	7bfa      	ldrb	r2, [r7, #15]
 80010d2:	490b      	ldr	r1, [pc, #44]	; (8001100 <Slave_States+0xd4>)
 80010d4:	4613      	mov	r3, r2
 80010d6:	009b      	lsls	r3, r3, #2
 80010d8:	4413      	add	r3, r2
 80010da:	00db      	lsls	r3, r3, #3
 80010dc:	440b      	add	r3, r1
 80010de:	3324      	adds	r3, #36	; 0x24
 80010e0:	681b      	ldr	r3, [r3, #0]
 80010e2:	2003      	movs	r0, #3
 80010e4:	4798      	blx	r3
		}

		break ;
 80010e6:	e003      	b.n	80010f0 <Slave_States+0xc4>
		break ;
 80010e8:	bf00      	nop
 80010ea:	e002      	b.n	80010f2 <Slave_States+0xc6>
		break ;
 80010ec:	bf00      	nop
 80010ee:	e000      	b.n	80010f2 <Slave_States+0xc6>
		break ;
 80010f0:	bf00      	nop
	}
	}
}
 80010f2:	bf00      	nop
 80010f4:	3710      	adds	r7, #16
 80010f6:	46bd      	mov	sp, r7
 80010f8:	bd80      	pop	{r7, pc}
 80010fa:	bf00      	nop
 80010fc:	40005400 	.word	0x40005400
 8001100:	20000058 	.word	0x20000058

08001104 <I2C1_ER_IRQHandler>:
void I2C1_ER_IRQHandler(void)
{
 8001104:	b480      	push	{r7}
 8001106:	af00      	add	r7, sp, #0

}
 8001108:	bf00      	nop
 800110a:	46bd      	mov	sp, r7
 800110c:	bc80      	pop	{r7}
 800110e:	4770      	bx	lr

08001110 <RCC_Get_SYSCLK_Frequency>:
const uint8_t AHBPrescTable[16U] = {0,0,0,0,0,0,0,0,1,2,3,4,6,7,8,9}; // Shift 1 right == multiply by 2



uint32_t RCC_Get_SYSCLK_Frequency(void)
{
 8001110:	b480      	push	{r7}
 8001112:	af00      	add	r7, sp, #0
	//Set and cleared by hardware to indicate which clock source is used as system clock.
	//00: HSI oscillator used as system clock
	//01: HSE oscillator used as system clock
	//10: PLL used as system clock
	//11: Not applicable
	switch ((RCC->CFGR >> 2) & 0b11) {
 8001114:	4b0c      	ldr	r3, [pc, #48]	; (8001148 <RCC_Get_SYSCLK_Frequency+0x38>)
 8001116:	685b      	ldr	r3, [r3, #4]
 8001118:	089b      	lsrs	r3, r3, #2
 800111a:	f003 0303 	and.w	r3, r3, #3
 800111e:	2b02      	cmp	r3, #2
 8001120:	d00a      	beq.n	8001138 <RCC_Get_SYSCLK_Frequency+0x28>
 8001122:	2b02      	cmp	r3, #2
 8001124:	d80a      	bhi.n	800113c <RCC_Get_SYSCLK_Frequency+0x2c>
 8001126:	2b00      	cmp	r3, #0
 8001128:	d002      	beq.n	8001130 <RCC_Get_SYSCLK_Frequency+0x20>
 800112a:	2b01      	cmp	r3, #1
 800112c:	d002      	beq.n	8001134 <RCC_Get_SYSCLK_Frequency+0x24>
 800112e:	e005      	b.n	800113c <RCC_Get_SYSCLK_Frequency+0x2c>
	case 0:
		return HSI_RC_Clk;
 8001130:	4b06      	ldr	r3, [pc, #24]	; (800114c <RCC_Get_SYSCLK_Frequency+0x3c>)
 8001132:	e004      	b.n	800113e <RCC_Get_SYSCLK_Frequency+0x2e>
		break;
	case 1:
		return HSE_Clock;
 8001134:	4b06      	ldr	r3, [pc, #24]	; (8001150 <RCC_Get_SYSCLK_Frequency+0x40>)
 8001136:	e002      	b.n	800113e <RCC_Get_SYSCLK_Frequency+0x2e>
		break;
	case 2:
		return 16000000;
 8001138:	4b05      	ldr	r3, [pc, #20]	; (8001150 <RCC_Get_SYSCLK_Frequency+0x40>)
 800113a:	e000      	b.n	800113e <RCC_Get_SYSCLK_Frequency+0x2e>
		break;
	}
	return HSI_RC_Clk;
 800113c:	4b03      	ldr	r3, [pc, #12]	; (800114c <RCC_Get_SYSCLK_Frequency+0x3c>)
}
 800113e:	4618      	mov	r0, r3
 8001140:	46bd      	mov	sp, r7
 8001142:	bc80      	pop	{r7}
 8001144:	4770      	bx	lr
 8001146:	bf00      	nop
 8001148:	40021000 	.word	0x40021000
 800114c:	007a1200 	.word	0x007a1200
 8001150:	00f42400 	.word	0x00f42400

08001154 <RCC_Get_HCLK_Frequency>:
uint32_t RCC_Get_HCLK_Frequency(void)
{
 8001154:	b580      	push	{r7, lr}
 8001156:	af00      	add	r7, sp, #0
	//Get SYSCLK source and Compute HCLK frequency
	return (RCC_Get_SYSCLK_Frequency() >> AHBPrescTable[(RCC->CFGR >> 4) & 0xF]);
 8001158:	f7ff ffda 	bl	8001110 <RCC_Get_SYSCLK_Frequency>
 800115c:	4602      	mov	r2, r0
 800115e:	4b05      	ldr	r3, [pc, #20]	; (8001174 <RCC_Get_HCLK_Frequency+0x20>)
 8001160:	685b      	ldr	r3, [r3, #4]
 8001162:	091b      	lsrs	r3, r3, #4
 8001164:	f003 030f 	and.w	r3, r3, #15
 8001168:	4903      	ldr	r1, [pc, #12]	; (8001178 <RCC_Get_HCLK_Frequency+0x24>)
 800116a:	5ccb      	ldrb	r3, [r1, r3]
 800116c:	fa22 f303 	lsr.w	r3, r2, r3
}
 8001170:	4618      	mov	r0, r3
 8001172:	bd80      	pop	{r7, pc}
 8001174:	40021000 	.word	0x40021000
 8001178:	08001308 	.word	0x08001308

0800117c <RCC_Get_PCLK1_Frequency>:
uint32_t RCC_Get_PCLK1_Frequency(void)
{
 800117c:	b580      	push	{r7, lr}
 800117e:	af00      	add	r7, sp, #0
	//Get HCLK source and Compute PCLK1 frequency
	return (RCC_Get_HCLK_Frequency() >> APBPrescTable[(RCC->CFGR >> 8) & 0b111]);
 8001180:	f7ff ffe8 	bl	8001154 <RCC_Get_HCLK_Frequency>
 8001184:	4602      	mov	r2, r0
 8001186:	4b05      	ldr	r3, [pc, #20]	; (800119c <RCC_Get_PCLK1_Frequency+0x20>)
 8001188:	685b      	ldr	r3, [r3, #4]
 800118a:	0a1b      	lsrs	r3, r3, #8
 800118c:	f003 0307 	and.w	r3, r3, #7
 8001190:	4903      	ldr	r1, [pc, #12]	; (80011a0 <RCC_Get_PCLK1_Frequency+0x24>)
 8001192:	5ccb      	ldrb	r3, [r1, r3]
 8001194:	fa22 f303 	lsr.w	r3, r2, r3
}
 8001198:	4618      	mov	r0, r3
 800119a:	bd80      	pop	{r7, pc}
 800119c:	40021000 	.word	0x40021000
 80011a0:	08001300 	.word	0x08001300

080011a4 <SPI1_IRQHandler>:
	}
	*data_buffer = SPIx->DR ;
}

//-------------------------------------------ISRs---------------------------------------------------
void SPI1_IRQHandler (void) {
 80011a4:	b580      	push	{r7, lr}
 80011a6:	b082      	sub	sp, #8
 80011a8:	af00      	add	r7, sp, #0
	IRQ_SOURCE irq_src ;
	irq_src.TXE = ( (SPI1->SR & (1 << 1)) >> 1 ) ;
 80011aa:	4b13      	ldr	r3, [pc, #76]	; (80011f8 <SPI1_IRQHandler+0x54>)
 80011ac:	689b      	ldr	r3, [r3, #8]
 80011ae:	085b      	lsrs	r3, r3, #1
 80011b0:	f003 0301 	and.w	r3, r3, #1
 80011b4:	b2da      	uxtb	r2, r3
 80011b6:	793b      	ldrb	r3, [r7, #4]
 80011b8:	f362 0300 	bfi	r3, r2, #0, #1
 80011bc:	713b      	strb	r3, [r7, #4]
	irq_src.RXNE = ( (SPI1->SR & (1 << 0)) >> 0 ) ;
 80011be:	4b0e      	ldr	r3, [pc, #56]	; (80011f8 <SPI1_IRQHandler+0x54>)
 80011c0:	689b      	ldr	r3, [r3, #8]
 80011c2:	f003 0301 	and.w	r3, r3, #1
 80011c6:	b2da      	uxtb	r2, r3
 80011c8:	793b      	ldrb	r3, [r7, #4]
 80011ca:	f362 0341 	bfi	r3, r2, #1, #1
 80011ce:	713b      	strb	r3, [r7, #4]
	irq_src.ERRI = ( (SPI1->SR & (1 << 4)) >> 4 ) ;
 80011d0:	4b09      	ldr	r3, [pc, #36]	; (80011f8 <SPI1_IRQHandler+0x54>)
 80011d2:	689b      	ldr	r3, [r3, #8]
 80011d4:	091b      	lsrs	r3, r3, #4
 80011d6:	f003 0301 	and.w	r3, r3, #1
 80011da:	b2da      	uxtb	r2, r3
 80011dc:	793b      	ldrb	r3, [r7, #4]
 80011de:	f362 0382 	bfi	r3, r2, #2, #1
 80011e2:	713b      	strb	r3, [r7, #4]
	G_SPI_Config[0]->IRQ_CallBack(irq_src) ;
 80011e4:	4b05      	ldr	r3, [pc, #20]	; (80011fc <SPI1_IRQHandler+0x58>)
 80011e6:	681b      	ldr	r3, [r3, #0]
 80011e8:	695b      	ldr	r3, [r3, #20]
 80011ea:	7938      	ldrb	r0, [r7, #4]
 80011ec:	4798      	blx	r3
}
 80011ee:	bf00      	nop
 80011f0:	3708      	adds	r7, #8
 80011f2:	46bd      	mov	sp, r7
 80011f4:	bd80      	pop	{r7, pc}
 80011f6:	bf00      	nop
 80011f8:	40013000 	.word	0x40013000
 80011fc:	200000a8 	.word	0x200000a8

08001200 <SPI2_IRQHandler>:

void SPI2_IRQHandler (void) {
 8001200:	b580      	push	{r7, lr}
 8001202:	b082      	sub	sp, #8
 8001204:	af00      	add	r7, sp, #0
	IRQ_SOURCE irq_src ;
	irq_src.TXE = ( (SPI2->SR & (1 << 1)) >> 1 ) ;
 8001206:	4b13      	ldr	r3, [pc, #76]	; (8001254 <SPI2_IRQHandler+0x54>)
 8001208:	689b      	ldr	r3, [r3, #8]
 800120a:	085b      	lsrs	r3, r3, #1
 800120c:	f003 0301 	and.w	r3, r3, #1
 8001210:	b2da      	uxtb	r2, r3
 8001212:	793b      	ldrb	r3, [r7, #4]
 8001214:	f362 0300 	bfi	r3, r2, #0, #1
 8001218:	713b      	strb	r3, [r7, #4]
	irq_src.RXNE = ( (SPI2->SR & (1 << 0)) >> 0 ) ;
 800121a:	4b0e      	ldr	r3, [pc, #56]	; (8001254 <SPI2_IRQHandler+0x54>)
 800121c:	689b      	ldr	r3, [r3, #8]
 800121e:	f003 0301 	and.w	r3, r3, #1
 8001222:	b2da      	uxtb	r2, r3
 8001224:	793b      	ldrb	r3, [r7, #4]
 8001226:	f362 0341 	bfi	r3, r2, #1, #1
 800122a:	713b      	strb	r3, [r7, #4]
	irq_src.ERRI = ( (SPI2->SR & (1 << 4)) >> 4 ) ;
 800122c:	4b09      	ldr	r3, [pc, #36]	; (8001254 <SPI2_IRQHandler+0x54>)
 800122e:	689b      	ldr	r3, [r3, #8]
 8001230:	091b      	lsrs	r3, r3, #4
 8001232:	f003 0301 	and.w	r3, r3, #1
 8001236:	b2da      	uxtb	r2, r3
 8001238:	793b      	ldrb	r3, [r7, #4]
 800123a:	f362 0382 	bfi	r3, r2, #2, #1
 800123e:	713b      	strb	r3, [r7, #4]
	G_SPI_Config[1]->IRQ_CallBack(irq_src) ;
 8001240:	4b05      	ldr	r3, [pc, #20]	; (8001258 <SPI2_IRQHandler+0x58>)
 8001242:	685b      	ldr	r3, [r3, #4]
 8001244:	695b      	ldr	r3, [r3, #20]
 8001246:	7938      	ldrb	r0, [r7, #4]
 8001248:	4798      	blx	r3

}
 800124a:	bf00      	nop
 800124c:	3708      	adds	r7, #8
 800124e:	46bd      	mov	sp, r7
 8001250:	bd80      	pop	{r7, pc}
 8001252:	bf00      	nop
 8001254:	40003800 	.word	0x40003800
 8001258:	200000a8 	.word	0x200000a8

0800125c <USART1_IRQHandler>:
void UART_TRANS_COMPLETE(USART_t *USARTx )
{
	while(USARTx->SR & 1<<6);
}
void USART1_IRQHandler (void)
{
 800125c:	b580      	push	{r7, lr}
 800125e:	af00      	add	r7, sp, #0
	Global_config->IRQ_CallBack();
 8001260:	4b02      	ldr	r3, [pc, #8]	; (800126c <USART1_IRQHandler+0x10>)
 8001262:	681b      	ldr	r3, [r3, #0]
 8001264:	691b      	ldr	r3, [r3, #16]
 8001266:	4798      	blx	r3
}
 8001268:	bf00      	nop
 800126a:	bd80      	pop	{r7, pc}
 800126c:	200000b0 	.word	0x200000b0

08001270 <USART2_IRQHandler>:
void USART2_IRQHandler (void)
{
 8001270:	b580      	push	{r7, lr}
 8001272:	af00      	add	r7, sp, #0
	Global_config->IRQ_CallBack();
 8001274:	4b02      	ldr	r3, [pc, #8]	; (8001280 <USART2_IRQHandler+0x10>)
 8001276:	681b      	ldr	r3, [r3, #0]
 8001278:	691b      	ldr	r3, [r3, #16]
 800127a:	4798      	blx	r3
}
 800127c:	bf00      	nop
 800127e:	bd80      	pop	{r7, pc}
 8001280:	200000b0 	.word	0x200000b0

08001284 <USART3_IRQHandler>:
void USART3_IRQHandler (void)
{
 8001284:	b580      	push	{r7, lr}
 8001286:	af00      	add	r7, sp, #0
	Global_config->IRQ_CallBack();
 8001288:	4b02      	ldr	r3, [pc, #8]	; (8001294 <USART3_IRQHandler+0x10>)
 800128a:	681b      	ldr	r3, [r3, #0]
 800128c:	691b      	ldr	r3, [r3, #16]
 800128e:	4798      	blx	r3
}
 8001290:	bf00      	nop
 8001292:	bd80      	pop	{r7, pc}
 8001294:	200000b0 	.word	0x200000b0

08001298 <__libc_init_array>:
 8001298:	b570      	push	{r4, r5, r6, lr}
 800129a:	2600      	movs	r6, #0
 800129c:	4d0c      	ldr	r5, [pc, #48]	; (80012d0 <__libc_init_array+0x38>)
 800129e:	4c0d      	ldr	r4, [pc, #52]	; (80012d4 <__libc_init_array+0x3c>)
 80012a0:	1b64      	subs	r4, r4, r5
 80012a2:	10a4      	asrs	r4, r4, #2
 80012a4:	42a6      	cmp	r6, r4
 80012a6:	d109      	bne.n	80012bc <__libc_init_array+0x24>
 80012a8:	f000 f81a 	bl	80012e0 <_init>
 80012ac:	2600      	movs	r6, #0
 80012ae:	4d0a      	ldr	r5, [pc, #40]	; (80012d8 <__libc_init_array+0x40>)
 80012b0:	4c0a      	ldr	r4, [pc, #40]	; (80012dc <__libc_init_array+0x44>)
 80012b2:	1b64      	subs	r4, r4, r5
 80012b4:	10a4      	asrs	r4, r4, #2
 80012b6:	42a6      	cmp	r6, r4
 80012b8:	d105      	bne.n	80012c6 <__libc_init_array+0x2e>
 80012ba:	bd70      	pop	{r4, r5, r6, pc}
 80012bc:	f855 3b04 	ldr.w	r3, [r5], #4
 80012c0:	4798      	blx	r3
 80012c2:	3601      	adds	r6, #1
 80012c4:	e7ee      	b.n	80012a4 <__libc_init_array+0xc>
 80012c6:	f855 3b04 	ldr.w	r3, [r5], #4
 80012ca:	4798      	blx	r3
 80012cc:	3601      	adds	r6, #1
 80012ce:	e7f2      	b.n	80012b6 <__libc_init_array+0x1e>
 80012d0:	08001318 	.word	0x08001318
 80012d4:	08001318 	.word	0x08001318
 80012d8:	08001318 	.word	0x08001318
 80012dc:	0800131c 	.word	0x0800131c

080012e0 <_init>:
 80012e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80012e2:	bf00      	nop
 80012e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80012e6:	bc08      	pop	{r3}
 80012e8:	469e      	mov	lr, r3
 80012ea:	4770      	bx	lr

080012ec <_fini>:
 80012ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80012ee:	bf00      	nop
 80012f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80012f2:	bc08      	pop	{r3}
 80012f4:	469e      	mov	lr, r3
 80012f6:	4770      	bx	lr
